{"version":3,"file":"main.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAMA;AACA;AACA;AACA;AAKA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAqBA;;;;;;;;;;;;;;;;;;;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;;;;;;;;;;;;;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;;;;;;;;;;;;;;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxEA;AACA;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACzbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACvOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC3OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACjJA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://phs/./node_modules/graphics/index.js","webpack://phs/./node_modules/graphics/src/BufferAttribute.js","webpack://phs/./node_modules/graphics/src/Drawer.js","webpack://phs/./node_modules/graphics/src/MeshRenderer.js","webpack://phs/./node_modules/graphics/src/PrimitiveRenderer.js","webpack://phs/./node_modules/graphics/src/attribTypeProps.js","webpack://phs/./node_modules/graphics/src/entity.js","webpack://phs/./node_modules/graphics/src/enums.js","webpack://phs/./node_modules/graphics/src/gltfUtils.js","webpack://phs/./node_modules/graphics/src/primitives.js","webpack://phs/./node_modules/graphics/src/programInfo.js","webpack://phs/./node_modules/graphics/src/render/shaders/Default.js","webpack://phs/./node_modules/graphics/src/render/shaders/Lighting.js","webpack://phs/./node_modules/graphics/src/render/shaders/glsl.js","webpack://phs/./node_modules/graphics/src/render/shaders/index.js","webpack://phs/./node_modules/graphics/src/textureUtils.js","webpack://phs/./node_modules/math/index.js","webpack://phs/./node_modules/math/src/aabb.js","webpack://phs/./node_modules/math/src/m3.js","webpack://phs/./node_modules/math/src/m4.js","webpack://phs/./node_modules/math/src/node.js","webpack://phs/./node_modules/math/src/vector.js","webpack://phs/./src/GSsolver.js","webpack://phs/./src/collider.js","webpack://phs/./src/constraints.js","webpack://phs/./src/contact.js","webpack://phs/./src/eventEmitter.js","webpack://phs/./src/gjk.js","webpack://phs/./src/island.js","webpack://phs/./src/manifold.js","webpack://phs/./src/physics.js","webpack://phs/./src/simulation.js","webpack://phs/./src/tree.js","webpack://phs/webpack/bootstrap","webpack://phs/webpack/runtime/compat get default export","webpack://phs/webpack/runtime/define property getters","webpack://phs/webpack/runtime/hasOwnProperty shorthand","webpack://phs/webpack/runtime/make namespace object","webpack://phs/./index.js"],"sourcesContent":["import { BufferInfo, DynamicBufferInfo } from \"./src/BufferAttribute\";\nimport {\n  PrimitiveRenderInfoFromArrayData,\n  ArrayDataFromGltf,\n  EntityDataFromGltf,\n  GLTF,\n} from \"./src/gltfUtils\";\nimport { MeshRenderer, SkinnedMeshRenderer } from \"./src/MeshRenderer\";\nimport { createBox, createCone, createCircle } from \"./src/primitives\";\nimport PrimitiveRenderer from \"./src/PrimitiveRenderer\";\nimport {\n  getGLTypeForTypedArray,\n  ProgramInfo,\n  expandedTypedArray,\n} from \"./src/programInfo\";\nimport Drawer from \"./src/Drawer\";\nimport {\n  Texture,\n  makeImgFromSvgXml,\n  makeStripeImg,\n  setTextureUnits,\n} from \"./src/textureUtils\";\nimport Entity from \"./src/entity\";\nimport { lightingProgram, defaultProgram } from \"./src/render/shaders\";\nclass GLcontextWrapper {\n  constructor(canvas_id) {\n    const canvas = document.querySelector(`#${canvas_id}`);\n    const gl = canvas.getContext(\"webgl2\");\n\n    if (!gl) {\n      throw new Error(\"No webgl!\");\n    }\n    this.gl = gl;\n    this.textures = {};\n    this.renderCache = {\n      lastUsedProgramInfo: null,\n    };\n    this.programs = {};\n  }\n  getLastUsedProgramInfo() {\n    return this.renderCache.lastUsedProgramInfo;\n  }\n  setLastUsedProgram(programInfo) {\n    this.renderCache.lastUsedProgramInfo = programInfo;\n    return this;\n  }\n  useProgramInfo(programInfo) {\n    if (programInfo != this.getLastUsedProgramInfo()) {\n      this.gl.useProgram(programInfo.program);\n      this.setLastUsedProgram(programInfo);\n    }\n    return this;\n  }\n  resizeCanvasToDisplaySize(multiplier = 1) {\n    const canvas = this.gl.canvas;\n    const width = (canvas.clientWidth * multiplier) | 0;\n    const height = (canvas.clientHeight * multiplier) | 0;\n\n    canvas.width = width;\n    canvas.height = height;\n    return this;\n  }\n  resizeCanvas(width, height) {\n    const canvas = this.gl.canvas;\n    canvas.width = width;\n    canvas.height = height;\n    return this;\n  }\n  getContext() {\n    return this.gl;\n  }\n  getCanvasRect() {\n    return this.gl.canvas.getBoundin;\n  }\n  createTexture(textureName) {\n    const texture = new Texture(this.gl);\n    this.textures = { ...this.textures, [textureName]: texture };\n    return this;\n  }\n  getTexture(textureName) {\n    return this.textures[textureName];\n  }\n  setTextureUnit(textureName, unitNum) {\n    const texture = this.getTexture(textureName).texture;\n    setTextureUnits(this.gl, texture, unitNum);\n    return this;\n  }\n}\n\nexport {\n  GLTF,\n  GLcontextWrapper,\n  Texture,\n  makeImgFromSvgXml,\n  makeStripeImg,\n  Entity,\n  PrimitiveRenderer,\n  EntityDataFromGltf,\n  PrimitiveRenderInfoFromArrayData,\n  ArrayDataFromGltf,\n  MeshRenderer,\n  SkinnedMeshRenderer,\n  createBox,\n  ProgramInfo,\n  Drawer,\n  createCone,\n  createCircle,\n  lightingProgram,\n  defaultProgram,\n};\n","import { getGLTypeForTypedArray } from \"./programInfo\";\nimport { TYPED_ARRAYS } from \"./enums\";\nconst createIndicesBuffer = (gl, indices) => {\n  const buffer = gl.createBuffer();\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);\n  return buffer;\n};\nconst floatAttribSetter = (props) => {\n  const {\n    numComponents,\n    type,\n    location,\n    numAttributes,\n    stride,\n    offset,\n    buffer,\n    gl,\n    divisor,\n  } = props;\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  for (let i = 0; i < numAttributes; i++) {\n    const _offset = numComponents * i * TYPED_ARRAYS[type].BYTES_PER_ELEMENT;\n    gl.enableVertexAttribArray(location + i);\n    gl.vertexAttribPointer(\n      location + i,\n      numComponents,\n      type,\n      false,\n      stride,\n      offset + _offset\n    );\n\n    if (divisor) gl.vertexAttribDivisor(location + i, divisor);\n  }\n};\nconst intAttribSetter = (props) => {\n  const {\n    numComponents,\n    type,\n    location,\n    numAttributes,\n    stride,\n    offset,\n    buffer,\n    gl,\n    divisor,\n  } = props;\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n  for (let i = 0; i < numAttributes; i++) {\n    const _offset = numComponents * i * TYPED_ARRAYS[type].BYTES_PER_ELEMENT;\n    gl.enableVertexAttribArray(location + i);\n    gl.vertexAttribIPointer(\n      location + i,\n      numComponents,\n      type,\n      false,\n      stride,\n      offset + _offset\n    );\n    if (divisor) gl.vertexAttribDivisor(location + i, divisor);\n  }\n};\nconst attribTypeMap = {};\nattribTypeMap[0x1400] = intAttribSetter;\nattribTypeMap[0x1406] = floatAttribSetter;\nattribTypeMap[0x1401] = intAttribSetter;\nattribTypeMap[0x1404] = intAttribSetter;\nattribTypeMap[0x1405] = intAttribSetter;\nattribTypeMap[0x1402] = intAttribSetter;\nattribTypeMap[0x1403] = intAttribSetter;\n\nconst setAttributes = (gl, bufferInfo, divisor) => {\n  const { type } = bufferInfo;\n  const setter = attribTypeMap[type];\n  setter(bufferInfo, divisor);\n};\nclass BufferController {\n  constructor(gl, target = 0x8892) {\n    this.target = target;\n    this.buffer = gl.createBuffer();\n    this.gl = gl;\n    this.bufferData = (data, byteLength, usage = gl.STATIC_DRAW) => {\n      gl.bindBuffer(target, this.buffer);\n      gl.bufferData(target, data || byteLength, usage);\n    };\n    this.bufferSubData = (data, offset = 0) => {\n      gl.bindBuffer(target, this.buffer);\n      gl.bufferSubData(target, offset, data);\n    };\n  }\n}\nclass AttributeSetter {\n  constructor(info) {\n    this.stride = info.stride || 0;\n    this.numComponents = info.numComponents;\n    this.numAttributes = info.numAttributes || 1;\n    this.offset = info.offset || 0;\n    this.type = info.type;\n    this.location = info.location;\n  }\n  setAttribute(bufferController, divisor) {\n    const { type } = this;\n    const setter = attribTypeMap[type];\n    setter(this, bufferController, divisor);\n  }\n}\nclass BufferAttribute {\n  constructor(gl, info) {\n    this.gl = gl;\n    this.buffer = gl.createBuffer();\n    this.stride = info.stride || 0;\n    this.numComponents = info.numComponents;\n    this.numAttributes = info.numAttributes || 1;\n    this.offset = info.offset || 0;\n    this.type = info.type;\n    this.location = info.location;\n    this.divisor = info.divisor;\n  }\n  setAttribute() {\n    const { type, gl } = this;\n    const setter = attribTypeMap[type];\n    setter(this);\n  }\n  bufferData(data, byteLength, usage = 0x88e4) {\n    const { gl, buffer } = this;\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, data || byteLength, usage);\n  }\n  bufferSubData(data, offset = 0) {\n    const { gl, buffer } = this;\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferSubData(gl.ARRAY_BUFFER, offset, data);\n  }\n}\n\nexport {\n  BufferAttribute,\n  createIndicesBuffer,\n  AttributeSetter,\n  BufferController,\n};\n","import { m4 } from \"math\";\n\nconst degToRad = (d) => (d * Math.PI) / 180;\n\nconst fieldOfViewRadians = degToRad(90);\n\nclass Drawer {\n  constructor() {\n    this.context = null;\n    this.projectionMatrix = null;\n    this.fieldOfViewRadians = degToRad(90);\n  }\n  setContext(glContextWrapper) {\n    this.context = glContextWrapper;\n    return this;\n  }\n  setFieldOfView(angle) {\n    this.fieldOfViewRadians = degToRad(angle);\n    return this;\n  }\n  update3DProjectionMatrix(zNear = 0.01, zFar = 2000) {\n    const { gl } = this.context;\n    const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\n    this.projectionMatrix = m4.perspective(\n      fieldOfViewRadians,\n      aspect,\n      zNear,\n      zFar\n    );\n    return this;\n  }\n\n  getViewProjectionMatrix(cameraMatrix) {\n    const { projectionMatrix } = this;\n    const { gl } = this.context;\n    const viewMatrix = m4.inverse(cameraMatrix);\n    return m4.multiply(projectionMatrix, viewMatrix);\n  }\n  draw(renderInfo, uniforms, cameraMatrix) {\n    const viewProjectionMatrix = this.getViewProjectionMatrix(cameraMatrix);\n    const {\n      vao,\n      mode,\n      offset,\n      numElements,\n      indices,\n      componentType,\n      programInfo,\n    } = renderInfo;\n    const { gl } = this.context;\n\n    const worldViewProjection = m4.multiply(\n      viewProjectionMatrix,\n      uniforms.u_matrix\n    );\n    const worldMatrix = uniforms.u_matrix;\n    this.context.useProgramInfo(programInfo);\n    this.context\n      .getLastUsedProgramInfo()\n      .setUniforms({ ...uniforms, worldMatrix, worldViewProjection });\n    if (vao) gl.bindVertexArray(vao);\n    if (!indices) {\n      gl.drawArrays(mode, offset, numElements);\n      return;\n    }\n    gl.drawElements(mode, numElements, componentType, offset);\n  }\n  drawInstanced(renderInfo, uniforms, cameraMatrix, numInstances) {\n    const viewProjectionMatrix = this.getViewProjectionMatrix(cameraMatrix);\n    const { gl } = this.context;\n    const { vao, mode, offset, numElements, indices, programInfo } = renderInfo;\n    const worldViewProjection = m4.multiply(\n      viewProjectionMatrix,\n      uniforms.u_matrix\n    );\n    const worldMatrix = uniforms.u_matrix;\n    this.context.useProgramInfo(programInfo);\n    this.context\n      .getLastUsedProgramInfo()\n      .setUniforms({ ...uniforms, worldMatrix, worldViewProjection });\n    gl.bindVertexArray(vao);\n    if (!indices) {\n      gl.drawArraysInstanced(mode, offset, numElements, numInstances);\n      return;\n    }\n    gl.drawElementsInstanced(\n      mode,\n      numElements,\n      gl.UNSIGNED_SHORT,\n      offset,\n      numInstances\n    );\n  }\n}\nexport default Drawer;\n","import getAttributePropsByType from \"./attribTypeProps\";\nimport attribTypeProps from \"./attribTypeProps\";\nimport { BufferAttribute } from \"./BufferAttribute\";\nclass MeshRenderer {\n  constructor({ primitives, name }) {\n    this.primitives = primitives;\n    this.name = name;\n    this.context = null;\n    this.buffers = {};\n  }\n  setContext(glContextWrapper) {\n    this.context = glContextWrapper;\n    for (let i = 0, n = this.primitives.length; i < n; i++) {\n      this.primitives[i].setContext(glContextWrapper);\n    }\n    return this;\n  }\n  setProgramInfo(programInfo) {\n    for (let i = 0, n = this.primitives.length; i < n; i++) {\n      this.primitives[i].setProgramInfo(programInfo);\n    }\n    return this;\n  }\n  setDrawer(drawer) {\n    for (let i = 0, n = this.primitives.length; i < n; i++) {\n      this.primitives[i].setDrawer(drawer);\n    }\n    return this;\n  }\n  draw(uniforms, cameraMatrix) {\n    for (let i = 0, n = this.primitives.length; i < n; i++) {\n      this.primitives[i].draw(uniforms, cameraMatrix);\n    }\n    return this;\n  }\n  drawInstanced(uniforms, cameraMatrix, numInstances) {\n    for (let i = 0, n = this.primitives.length; i < n; i++) {\n      this.primitives[i].drawInstanced(uniforms, cameraMatrix, numInstances);\n    }\n    return this;\n  }\n  createPrimitiveBuffers() {\n    this.primitives.forEach((primitive) => primitive.createGeometryBuffers());\n    return this;\n  }\n  createBufferAttribData(name, type, params) {\n    const { gl } = this.context;\n    const attribProps = getAttributePropsByType(type);\n    const attributeProps = { ...attribProps, ...params };\n    const bufferAttribData = new BufferAttribute(gl, attributeProps);\n    this.buffers = { ...this.buffers, [name]: bufferAttribData };\n    return this;\n  }\n  bufferData(bufferName, data, byteLength) {\n    const bufferAttributeDescriptor = this.buffers[bufferName];\n\n    bufferAttributeDescriptor.bufferData(data, byteLength);\n    return this;\n  }\n  bufferSubData(bufferName, data, offset) {\n    const bufferAttributeDescriptor = this.buffers[bufferName];\n    bufferAttributeDescriptor.bufferSubData(data, byteLength, offset);\n    return this;\n  }\n  setAttribute(name) {\n    const bufferAttribData = this.buffers[name];\n    this.primitives.forEach((primitive) =>\n      primitive.setAttribute(bufferAttribData)\n    );\n    return this;\n  }\n  setPrimitiveAttributes() {\n    for (let i = 0, n = this.primitives.length; i < n; i++) {\n      this.primitives[i].setAttributes();\n    }\n    return this;\n  }\n}\nclass SkinnedMeshRenderer {\n  constructor(primitives, skin) {\n    this.primitives = primitives;\n    this.skin = skin;\n  }\n  draw(uniforms, cameraMatrix) {\n    this.skin.update(uniforms.u_matrix);\n    const _uniforms = {\n      u_jointTexture: this.skin.jointTexture,\n      u_numJoints: this.skin.joints.length,\n      ...uniforms,\n    };\n    for (let i = 0, n = this.primitives.length; i < n; i++) {\n      this.primitives[i].draw(_uniforms, cameraMatrix);\n    }\n  }\n}\nexport { MeshRenderer, SkinnedMeshRenderer };\n","import {\n  createIndicesBuffer,\n  BufferAttribute,\n  DynamicBufferAttribDescriptor,\n  BufferController,\n  AttributeSetter,\n} from \"./BufferAttribute\";\nimport { ELEMENT_SIZE } from \"./enums\";\nimport { getGLTypeForTypedArray } from \"./programInfo\";\nimport getAttributePropsByType from \"./attribTypeProps\";\n\nclass PrimitiveRenderer {\n  constructor(arrayData) {\n    this.buffers = {};\n    this.programInfo = null;\n    this.context = null;\n    this.drawer = null;\n    this.mode = null;\n    this.offset = null;\n    this.numElements = null;\n    this.vao = null;\n    this.componentType = null;\n    this.arrayData = arrayData;\n    const {componentType, numElements, mode } = arrayData;\n    this.numElements = numElements;\n    this.mode = mode;\n    this.componentType = componentType || 5123;\n  }\n  setContext(glContextWrapper) {\n    this.context = glContextWrapper;\n    return this;\n  }\n  createVAO() {\n    if (this.vao) return;\n    this.vao = this.context.gl.createVertexArray();\n    return this;\n  }\n  setMode(mode){\n    this.mode = mode\n    return this\n  }\n  createGeometryBuffers() {\n    const { arrayData } = this;\n    const { gl } = this.context;\n    const { attributes, indices, componentType, numElements, mode } = arrayData;\n   \n\n    if (attributes) {\n      Object.keys(attributes).forEach((attributeName) => {\n        const {\n          stride,\n          type,\n          offset,\n          location,\n          numComponents,\n          numAttributes,\n          data,\n          size,\n        } = attributes[attributeName];\n        const bufferAttributeDescriptor = new BufferAttribute(gl, {\n          stride,\n          type,\n          offset,\n          location,\n          numAttributes,\n          numComponents,\n          size,\n        });\n        bufferAttributeDescriptor.bufferData(data);\n        this.buffers = {\n          ...this.buffers,\n          [attributeName]: bufferAttributeDescriptor,\n        };\n      });\n    }\n    if (indices) {\n      const indicesBuffer = gl.createBuffer();\n      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indicesBuffer);\n      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);\n      this.indices = indicesBuffer;\n    }\n    return this;\n  }\n  setAttributes() {\n    const { gl } = this.context;\n\n    gl.bindVertexArray(this.vao);\n    for (const attrib in this.buffers) {\n      const bufferAttributeDescriptor = this.buffers[attrib];\n      bufferAttributeDescriptor.setAttribute();\n    }\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indices);\n    gl.bindVertexArray(null);\n\n    return this;\n  }\n  setDrawer(drawer) {\n    this.drawer = drawer;\n    return this;\n  }\n  setProgramInfo(programInfo) {\n    this.programInfo = programInfo;\n    return this;\n  }\n  createBufferAttribData(name, type, params) {\n    const { gl } = this.context;\n    const attribProps = getAttributePropsByType(type);\n    const attributeProps = { ...attribProps, ...params };\n    const bufferAttribData = new BufferAttribute(gl, attributeProps);\n    this.buffers = { ...this.buffers, [name]: bufferAttribData };\n    return this;\n  }\n  setBufferAttribData(name, bufferAttribData) {\n    this.buffers = { ...this.buffers, [name]: bufferAttribData };\n    return this;\n  }\n  setOwnAttribute(name, divisor) {\n    const { gl } = this.context;\n    const bufferAttribData = this.buffers[name];\n    gl.bindVertexArray(this.vao);\n    bufferAttribData.setAttribute(divisor);\n    gl.bindVertexArray(null);\n    return this;\n  }\n  setAttribute(bufferAttribData) {\n    const { gl } = this.context;\n    gl.bindVertexArray(this.vao);\n    bufferAttribData.setAttribute();\n    gl.bindVertexArray(null);\n    return this;\n  }\n  bufferData(bufferName, data, byteLength, usage) {\n    const bufferAttribData = this.buffers[bufferName];\n    bufferAttribData.bufferData(data, byteLength, usage);\n    return this;\n  }\n  bufferSubData(bufferName, data, offset) {\n    const bufferDesc = this.buffers[bufferName];\n    bufferDesc.bufferSubData(data, offset);\n    return this;\n  }\n  draw(uniforms, cameraMatrix) {\n    this.drawer.draw(this, uniforms, cameraMatrix);\n    return this;\n  }\n  drawInstanced(uniforms, cameraMatrix, numInstances) {\n    this.drawer.drawInstanced(this, uniforms, cameraMatrix, numInstances);\n    return this;\n  }\n}\n\nexport default PrimitiveRenderer;\n","const props = {\n  mat4: {\n    stride: 64,\n    byteLength: 64,\n    type: 0x1406,\n    numAttributes: 4,\n    numComponents: 4,\n  },\n  vec3: {\n    numComponents: 3,\n    type: 0x1406,\n    numAttributes: 1,\n  },\n};\nconst getAttributePropsByType = (type) => props[type];\nexport default getAttributePropsByType;\n","import { Node, TRS } from \"math\";\n\nclass Entity extends Node {\n  static makeEntity(entityDescription, rootNodeNdx) {\n    const { nodes, meshes } = entityDescription;\n    const rootNode = nodes[rootNodeNdx];\n    const makeNode = (nodeDescription, ndx) => {\n      const trs = new TRS(\n        nodeDescription.translation || [0, 0, 0],\n        nodeDescription.rotation || [0, 0, 0, 0],\n        nodeDescription.scale || [1, 1, 1]\n      );\n      const node = new Entity(nodeDescription.name, trs, ndx);\n      if (nodeDescription.mesh != undefined) {\n        node.renderer = meshes[nodeDescription.mesh];\n      }\n      if (nodeDescription.children) {\n        nodeDescription.children.forEach((childNdx) => {\n          const child = makeNode(nodes[childNdx], childNdx);\n          child.setParent(node);\n        });\n      }\n      return node;\n    };\n    return makeNode(rootNode, rootNodeNdx);\n  }\n  constructor(name, trs, ndx) {\n    super(name, trs);\n    this.ndx = ndx;\n    this.physics = null;\n    this.skinNdx = null;\n    this.objectsToDraw = [];\n    this.renderer = null;\n  }\n  updateObjectsToDraw() {\n    const queue = [this];\n    while (queue.length > 0) {\n      const node = queue.pop();\n      console.log(node);\n      if (node.renderer) this.objectsToDraw.push(node);\n      if (node.children) queue.push(...node.children);\n    }\n  }\n  traverse(fn) {\n    fn(this);\n    this.children.forEach((child) => child.traverse(fn));\n  }\n  find(ndx) {\n    let result = null;\n    const iter = (nodes) => {\n      for (let node of nodes) {\n        if (node.ndx === ndx) result = node;\n        else iter(node.children);\n      }\n    };\n    iter([this]);\n    return result;\n  }\n  findByName(name) {\n    let result = null;\n    const iter = (nodes) => {\n      for (let node of nodes) {\n        if (node.name === name) result = node;\n        else iter(node.children);\n      }\n    };\n    iter([this]);\n    return result;\n  }\n  render(uniforms, cameraMatrix) {\n    this.objectsToDraw.forEach((object) => {\n      object.renderer.draw(\n        { ...uniforms, u_matrix: object.worldMatrix },\n        cameraMatrix\n      );\n    });\n  }\n}\n\nexport default Entity;\n","const TYPED_ARRAYS = {\n    '5120': Int8Array,    \n    '5121': Uint8Array,   \n    '5122': Int16Array,   \n    '5123': Uint16Array,  \n    '5124': Int32Array,   \n    '5125': Uint32Array,  \n    '5126': Float32Array, \n}\nconst NUM_COMPONENTS = {\n    'SCALAR' : 1,\n    'VEC2' : 2,\n    'VEC3' : 3,\n    'VEC4' : 4,\n    'MAT2': 4,\n  'MAT3': 9,\n  'MAT4': 16,\n}\nconst LOCATIONS = {\n    'POSITION' : 0,\n    'NORMAL' : 1,\n    'WEIGHTS_0' : 2,\n    'JOINTS_0' : 3,\n    'TEXCOORD_0' : 4,\n}\nconst ELEMENT_SIZE = {\n    0x1406 : 4\n}\nexport {\n    LOCATIONS, NUM_COMPONENTS, TYPED_ARRAYS, ELEMENT_SIZE\n}","import PrimitiveRenderer from \"./PrimitiveRenderer\";\nimport { MeshRenderer } from \"./MeshRenderer\";\nimport { AttributeSetter, BufferController } from \"./BufferAttribute\";\nimport { NUM_COMPONENTS, TYPED_ARRAYS, LOCATIONS } from \"./enums\";\n\nconst ArrayDataFromGltf = (gltf, buffers) => {\n  const { bufferViews, accessors, meshes, nodes } = gltf;\n  const attribDataFromAccessor = (accessor) => {\n    const bufferView = bufferViews[accessor.bufferView];\n    const { count, componentType, type } = accessor;\n    const byteOffset = accessor.byteOffset || 0;\n    const { byteLength, target } = bufferView;\n    const stride = bufferView.byteStride || 0;\n    const bufferViewByteOffset = bufferView.byteOffset || 0;\n    const buffer = buffers[bufferView.buffer];\n\n    return {\n      data: new Uint8Array(buffer, bufferViewByteOffset, byteLength),\n      numComponents: NUM_COMPONENTS[type],\n      stride,\n      byteLength,\n      location: null,\n      count,\n      type: componentType,\n      offset: byteOffset || 0,\n      componentType: accessor.componentType,\n    };\n  };\n  const _meshes = meshes.map((mesh) => ({\n    primitives: mesh.primitives.map((_primitive) => {\n      const primitive = {\n        attributes: {},\n        mode: _primitive.mode,\n      };\n      if (_primitive.hasOwnProperty(\"indices\")) {\n        const indicesInfo = attribDataFromAccessor(\n          accessors[_primitive.indices]\n        );\n        primitive.indices = indicesInfo.data;\n        primitive.numElements = indicesInfo.count;\n        primitive.componentType = indicesInfo.componentType;\n      }\n      Object.keys(_primitive.attributes).forEach((attribName) => {\n        const attribute = _primitive.attributes[attribName];\n        primitive.attributes[attribName] = attribDataFromAccessor(\n          accessors[attribute]\n        );\n        //if(attribName === 'JOINTS_0') _primitive.attributes[attribName].data = new Uint32Array(_primitive.attributes[attribName].data)\n        primitive.attributes[attribName].location = LOCATIONS[attribName];\n      });\n      return primitive;\n    }),\n    name: mesh.name,\n  }));\n\n  return _meshes.map((mesh) => {\n    const primitives = mesh.primitives.map(\n      (primitive) => new PrimitiveRenderer(primitive)\n    );\n    const name = mesh.name;\n\n    return new MeshRenderer({ primitives, name });\n  });\n};\n\nconst PrimitiveRenderInfoFromArrayData = (meshes) =>\n  meshes.map((mesh) => {\n    const primitives = mesh.primitives.map(\n      (primitive) => new PrimitiveRenderer(primitive)\n    );\n    const name = mesh.name;\n    return new MeshRenderer({ name, primitives });\n  });\n\nconst EntityDataFromGltf = (gltf, buffers) =>\n  PrimitiveRenderInfoFromArrayData(ArrayDataFromGltf(gltf, buffers));\n\nclass GLTF {\n  constructor(gltf, binaryBuffers) {\n    const { nodes, meshes, skins } = gltf;\n    this.nodes = nodes;\n    this.meshes = ArrayDataFromGltf(gltf, binaryBuffers);\n  }\n}\nexport {\n  ArrayDataFromGltf,\n  PrimitiveRenderInfoFromArrayData,\n  EntityDataFromGltf,\n  GLTF,\n};\n","import { expandedTypedArray } from \"./programInfo.js\";\nimport { cross, diff, normalize } from \"math/src/vector.js\";\nconst linedBoxIndices = new Uint16Array([\n  0,\n  1,\n  1,\n  2,\n  2,\n  3,\n  3,\n  0, // front\n  0,\n  5,\n  5,\n  4,\n  4,\n  1,\n  1,\n  0, //bottom\n  0,\n  4,\n  4,\n  7,\n  7,\n  3,\n  3,\n  0, //left\n  1,\n  2,\n  2,\n  6,\n  6,\n  5,\n  5,\n  1, //right\n  4,\n  5,\n  5,\n  6,\n  6,\n  7,\n  7,\n  4, // back\n  2,\n  7,\n  7,\n  3,\n  3,\n  6,\n  6,\n  2, // top\n]);\n\nconst CUBE_FACE_INDICES = [\n  [3, 7, 5, 1], // right\n  [6, 2, 0, 4], // left\n  [6, 7, 3, 2], // ??\n  [0, 1, 5, 4], // ??\n  [7, 6, 4, 5], // front\n  [2, 3, 1, 0], // back\n];\n\nfunction createBox(_a = 1, _b = 1, _c = 1) {\n  const a = _a / 2,\n    b = _b / 2,\n    c = _c / 2;\n  const cornerVertices = [\n    [-a, -b, -c],\n    [+a, -b, -c],\n    [-a, +b, -c],\n    [+a, +b, -c],\n    [-a, -b, +c],\n    [+a, -b, +c],\n    [-a, +b, +c],\n    [+a, +b, +c],\n  ];\n\n  const faceNormals = [\n    [+1, +0, +0],\n    [-1, +0, +0],\n    [+0, +1, +0],\n    [+0, -1, +0],\n    [+0, +0, +1],\n    [+0, +0, -1],\n  ];\n\n  const uvCoords = [\n    [1, 0],\n    [0, 0],\n    [0, 1],\n    [1, 1],\n  ];\n  const numVertices = 6 * 4;\n  const positions = expandedTypedArray(new Float32Array(numVertices * 3));\n  const normals = expandedTypedArray(new Float32Array(numVertices * 3));\n  //const texCoords = webglUtils.createAugmentedTypedArray(2 , numVertices);\n  const indices = expandedTypedArray(new Uint16Array(6 * 2 * 3));\n\n  for (let f = 0; f < 6; ++f) {\n    const faceIndices = CUBE_FACE_INDICES[f];\n    for (let v = 0; v < 4; ++v) {\n      const position = cornerVertices[faceIndices[v]];\n      const normal = faceNormals[f];\n      positions.push(position);\n      normals.push(normal);\n    }\n\n    const offset = 4 * f;\n    indices.push(offset + 0, offset + 1, offset + 2);\n    indices.push(offset + 0, offset + 2, offset + 3);\n  }\n  const len = positions.byteLength;\n  const texcoord = new Float32Array([\n    // Front\n    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n    // Back\n    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n    // Top\n    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n    // Bottom\n    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n    // Right\n    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n    // Left\n    0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,\n  ]);\n\n  const ArrayData = {\n    attributes: {\n      NORMAL: {\n        data: normals,\n        count: 6 * 4 * 3,\n        location: 1,\n        byteLength: normals.byteLength,\n        stride: 0,\n        offset: 0,\n        numComponents: 3,\n        type: 5126,\n      },\n      POSITION: {\n        data: positions,\n        count: 6 * 4 * 3,\n        location: 0,\n        byteLength: positions.byteLength,\n        stride: 0,\n        offset: 0,\n        numComponents: 3,\n        type: 5126,\n      },\n      TEXCOORD_0: {\n        data: texcoord,\n        count: 48,\n        type: 5126,\n        offset: 0,\n        stride: 0,\n        byteLength: texcoord.byteLength,\n        location: 4,\n        numComponents: 2,\n      },\n    },\n    indices: indices,\n    numElements: indices.length,\n    componentType: 5123,\n    mode: 4,\n  };\n  return ArrayData;\n  /*return {\n          gltf : {\n            accessors : [\n            {\n                bufferView : 0,\n                byteOffset : 0,\n                count :72,\n                componentType : 5126,\n                type : 'VEC3'\n            },\n            {\n              bufferView : 1,\n              byteOffset : 0,\n              count : 72,\n              componentType : 5126,\n              type : 'VEC3'\n            },\n            {\n              bufferView : 2,\n              byteOffset : 0,\n              count : 36,\n              componentType : 5123,\n              type : 'SCALAR'\n            },\n            {\n              bufferView : 3,\n              byteOffset : 0,\n              count : 48,\n              componentType : 5126,\n              type : 'VEC2'\n            }\n            ],\n          bufferViews : [\n              {\n                buffer : 0,\n                byteLength : positions.byteLength,\n                byteOffset : 0\n              },\n              {\n                buffer : 1,\n                byteLength : normals.byteLength,\n                byteOffset : 0\n              },\n              {\n                buffer : 2,\n                byteLength : indices.byteLength,\n                byteOffset : 0\n              },\n              {\n                buffer : 3,\n                byteLength : texcoord.byteLength,\n                byteOffset : 0\n              }\n            ],\n          meshes : [\n            {\n              name : 'Cube',\n              primitives : [\n                {\n                  attributes : {\n                    NORMAL : 1,\n                    POSITION : 0,\n                    TEXCOORD_0 : 3\n                  },\n                  indices : 2,\n                  mode : 4\n                }\n              ]\n            }\n          ],\n          nodes : [\n            {\n              name : \"Cube\",\n              mesh : 0,\n              children : [1]\n            },\n            {\n              name : 'Cube2',\n              mesh : 0,\n              translation : [1,1,1]\n            }\n          ]\n        },\n        binaryBuffers : [\n          positions.buffer, normals.buffer, indices.buffer, texcoord.buffer\n        ]\n      };*/\n}\n\nconst createCone = (radius = 2, height = 2, numCorners = 4) => {\n  const vertices = [0, -height / 2, 0];\n  const normals = [];\n  const indices = [];\n\n  for (let i = 0; i < numCorners + 1; i++) {\n    const angle = (2 * i * Math.PI) / numCorners;\n    const x = Math.cos(angle) * radius;\n    const z = Math.sin(angle) * radius;\n    const y = -height / 2;\n    vertices.push(x, -height / 2, z);\n    normals.push(0, -1, 0);\n  }\n  for (let i = 0; i < numCorners; i++) {\n    indices.push(0, i + 1, i + 2);\n  }\n  //vertices.push(vertices[1], -height/2, vertices[3])\n  const n = vertices.length / 3;\n  const stride = 3;\n  const start = n;\n\n  for (let i = 0; i < numCorners + 2; i++) {\n    const angle = (2 * i * Math.PI) / numCorners;\n    const x = Math.cos(angle) * radius;\n    const z = Math.sin(angle) * radius;\n    const y = -height / 2;\n    const a = [vertices[i * 3], vertices[i * 3 + 1], vertices[i * 3 + 2]];\n    const b = [vertices[i * 3 + 3], vertices[i * 3 + 4], vertices[i * 3 + 5]];\n    const c = [0, height / 2, 0];\n    indices.push(\n      start + i * stride + 2,\n      start + i * stride + 1,\n      start + i * stride + 3\n    );\n    vertices.push(...c, ...a, ...b);\n    const normal = normalize(cross(diff(b, c), diff(a, c)));\n    normals.push(...normal, ...normal, ...normal);\n  }\n\n  const _normal = new Float32Array(normals);\n  const _position = new Float32Array(vertices);\n  const _indices = new Uint16Array(indices);\n  const ArrayData = {\n    attributes: {\n      POSITION: {\n        location: 0,\n        count: vertices.length,\n        offset: 0,\n        stride: 0,\n        numComponents: 3,\n        type: 5126,\n        data: _position,\n        byteLength: _position.byteLength,\n      },\n      NORMAL: {\n        location: 1,\n        count: normals.length,\n        numComponents: 3,\n        offset: 0,\n        stride: 0,\n        type: 5126,\n        data: _normal,\n        byteLength: _normal.byteLength,\n      },\n    },\n    componentType: 5123,\n    indices: _indices,\n    numElements: indices.length,\n    mode: 4,\n  };\n  return ArrayData;\n};\n\nconst createCircle = (radius, numCorners) => {\n  const vertices = [0, 0, 0];\n  const normals = [];\n  const indices = [];\n\n  for (let i = 0; i < numCorners + 1; i++) {\n    const angle = (2 * i * Math.PI) / numCorners;\n    const x = Math.cos(angle) * radius;\n    const z = Math.sin(angle) * radius;\n   \n    vertices.push(x, 0, z);\n    normals.push(0, 1, 0);\n  }\n  for (let i = 0; i < numCorners; i++) {\n    indices.push(0, i + 1, i + 2);\n  }\n\n  const _normal = new Float32Array(normals);\n  const _position = new Float32Array(vertices);\n  const _indices = new Uint16Array(indices);\n\n  const ArrayData = {\n    attributes: {\n      POSITION: {\n        location: 0,\n        count: vertices.length,\n        offset: 0,\n        stride: 0,\n        numComponents: 3,\n        type: 5126,\n        data: _position,\n        byteLength: _position.byteLength,\n      },\n      NORMAL: {\n        location: 1,\n        count: normals.length,\n        numComponents: 3,\n        offset: 0,\n        stride: 0,\n        type: 5126,\n        data: _normal,\n        byteLength: _normal.byteLength,\n      },\n    },\n    componentType: 5123,\n    indices: _indices,\n    numElements: indices.length,\n    mode: 4,\n  };\n  return ArrayData;\n};\n\nexport { createBox, createCone, createCircle};\n","function getGLTypeForTypedArray(gl, typedArray) {\n  if (typedArray instanceof Int8Array) {\n    return gl.BYTE;\n  } // eslint-disable-line\n  if (typedArray instanceof Uint8Array) {\n    return gl.UNSIGNED_BYTE;\n  } // eslint-disable-line\n  if (typedArray instanceof Uint8ClampedArray) {\n    return gl.UNSIGNED_BYTE;\n  } // eslint-disable-line\n  if (typedArray instanceof Int16Array) {\n    return gl.SHORT;\n  } // eslint-disable-line\n  if (typedArray instanceof Uint16Array) {\n    return gl.UNSIGNED_SHORT;\n  } // eslint-disable-line\n  if (typedArray instanceof Int32Array) {\n    return gl.INT;\n  } // eslint-disable-line\n  if (typedArray instanceof Uint32Array) {\n    return gl.UNSIGNED_INT;\n  } // eslint-disable-line\n  if (typedArray instanceof Float32Array) {\n    return gl.FLOAT;\n  } // eslint-disable-line\n  return false;\n}\nfunction expandedTypedArray(array) {\n  let cursor = 0;\n  array.push = function () {\n    for (let ii = 0; ii < arguments.length; ++ii) {\n      const value = arguments[ii];\n\n      if (\n        value instanceof Array ||\n        (value.buffer && value.buffer instanceof ArrayBuffer)\n      ) {\n        for (let jj = 0; jj < value.length; ++jj) {\n          array[cursor++] = value[jj];\n        }\n      } else {\n        array[cursor++] = value;\n      }\n    }\n  };\n\n  return array;\n}\n\nfunction createUniformSetters(gl, program) {\n  const createTextureSetter = (program, uniformInfo) => {\n    const location = gl.getUniformLocation(program, uniformInfo.name);\n\n    return (texBlockNum) => {\n      gl.uniform1i(location, texBlockNum);\n    };\n  };\n  function createUniformSetter(program, uniformInfo) {\n    const location = gl.getUniformLocation(program, uniformInfo.name);\n\n    const type = uniformInfo.type;\n\n    const isArray =\n      uniformInfo.size > 1 && uniformInfo.name.substr(-3) === \"[0]\";\n\n    if (type === gl.FLOAT && isArray) {\n      return function (v) {\n        gl.uniform1fv(location, v);\n      };\n    }\n    if (type === gl.FLOAT) {\n      return function (v) {\n        gl.uniform1f(location, v);\n      };\n    }\n    if (type === gl.FLOAT_VEC2) {\n      return function (v) {\n        gl.uniform2fv(location, v);\n      };\n    }\n    if (type === gl.FLOAT_VEC3) {\n      return function (v) {\n        gl.uniform3fv(location, v);\n      };\n    }\n    if (type === gl.FLOAT_VEC4) {\n      return function (v) {\n        gl.uniform4fv(location, v);\n      };\n    }\n    if (type === gl.INT && isArray) {\n      return function (v) {\n        gl.uniform1iv(location, v);\n      };\n    }\n    if (type === gl.INT) {\n      return function (v) {\n        gl.uniform1i(location, v);\n      };\n    }\n    if (type === gl.INT_VEC2) {\n      return function (v) {\n        gl.uniform2iv(location, v);\n      };\n    }\n    if (type === gl.INT_VEC3) {\n      return function (v) {\n        gl.uniform3iv(location, v);\n      };\n    }\n    if (type === gl.INT_VEC4) {\n      return function (v) {\n        gl.uniform4iv(location, v);\n      };\n    }\n    if (type === gl.BOOL) {\n      return function (v) {\n        gl.uniform1iv(location, v);\n      };\n    }\n    if (type === gl.BOOL_VEC2) {\n      return function (v) {\n        gl.uniform2iv(location, v);\n      };\n    }\n    if (type === gl.BOOL_VEC3) {\n      return function (v) {\n        gl.uniform3iv(location, v);\n      };\n    }\n    if (type === gl.BOOL_VEC4) {\n      return function (v) {\n        gl.uniform4iv(location, v);\n      };\n    }\n    if (type === gl.FLOAT_MAT2) {\n      return function (v) {\n        gl.uniformMatrix2fv(location, false, v);\n      };\n    }\n    if (type === gl.FLOAT_MAT3) {\n      return function (v) {\n        gl.uniformMatrix3fv(location, false, v);\n      };\n    }\n    if (type === gl.FLOAT_MAT4) {\n      return function (v) {\n        gl.uniformMatrix4fv(location, false, v);\n      };\n    }\n  }\n  const uniformSetters = {};\n  const textureSetters = {};\n  const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n\n  for (let ii = 0; ii < numUniforms; ++ii) {\n    const uniformInfo = gl.getActiveUniform(program, ii);\n    if (!uniformInfo) {\n      break;\n    }\n    let name = uniformInfo.name;\n    if (uniformInfo.type === gl.SAMPLER_2D) {\n      textureSetters[name] = createTextureSetter(program, uniformInfo);\n      continue;\n    }\n\n    if (name.substr(-3) === \"[0]\") {\n      name = name.substr(0, name.length - 3);\n    }\n    if (uniformInfo.size > 1) {\n      for (let i = 0; i < uniformInfo.size; i++) {\n        const obj = {\n          size: uniformInfo.size,\n          type: uniformInfo.type,\n          name: name + `[${i}]`,\n        };\n        uniformSetters[name + `[${i}]`] = createUniformSetter(program, obj);\n      }\n    } else {\n      const setter = createUniformSetter(program, uniformInfo);\n      uniformSetters[name] = setter;\n    }\n  }\n  return { uniformSetters, textureSetters };\n}\n\nclass ProgramInfo {\n  constructor(vs, fs) {\n    this.vs = vs;\n    this.fs = fs;\n    this.VAO = null;\n    this.uniformSetters = null;\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.program = null;\n    this.gl = null;\n  }\n  setContext(glContextWrapper) {\n    this.context = glContextWrapper;\n    return this;\n  }\n  createUniformSetters() {\n    const { gl } = this.context;\n    const { uniformSetters, textureSetters } = createUniformSetters(\n      gl,\n      this.program\n    );\n    this.textureSetters = textureSetters;\n    this.uniformSetters = uniformSetters;\n    return this;\n  }\n  compileShaders() {\n    const { gl } = this.context;\n    this.vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(this.vertexShader, this.vs);\n    gl.compileShader(this.vertexShader);\n    if (!gl.getShaderParameter(this.vertexShader, gl.COMPILE_STATUS)) {\n      throw new Error(gl.getShaderInfoLog(this.vertexShader));\n    }\n\n    this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(this.fragmentShader, this.fs);\n    gl.compileShader(this.fragmentShader);\n    if (!gl.getShaderParameter(this.fragmentShader, gl.COMPILE_STATUS)) {\n      throw new Error(gl.getShaderInfoLog(this.fragmentShader));\n    }\n\n    this.program = gl.createProgram();\n    gl.attachShader(this.program, this.vertexShader);\n    gl.attachShader(this.program, this.fragmentShader);\n    gl.linkProgram(this.program);\n    if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {\n      throw new Error(gl.getProgramInfoLog(this.program));\n    }\n    return this;\n  }\n  setUniforms(uniforms) {\n    this.context.useProgramInfo(this);\n    Object.keys(uniforms).forEach((name) => {\n      const setter = this.uniformSetters[name];\n      if (setter) setter(uniforms[name]);\n    });\n    return this;\n  }\n  setTextureUniformUnit(name, unit) {\n    this.context.useProgramInfo(this);\n    const setter = this.textureSetters[name];\n    if (setter) setter(unit);\n    return this;\n  }\n}\n\nexport { expandedTypedArray, ProgramInfo, getGLTypeForTypedArray };\n","import glsl from \"./glsl\";\nimport { ProgramInfo } from \"../../programInfo\";\nconst vert = glsl`#version 300 es\n\nprecision highp float;\n\nuniform mat4 worldViewProjection;\n\n\nlayout(location = 0) in vec4 a_position;\nvoid main() {\n  gl_Position = worldViewProjection * a_position;\n  gl_PointSize = 10.0;\n}`;\nconst frag = glsl`#version 300 es\nprecision highp float;\n \n\n\nuniform vec4 u_color;\nout vec4 outColor;\nvoid main() {\n  \n  \n  outColor = u_color;\n \n  \n  \n}\n`;\nexport default new ProgramInfo(vert, frag);\n","\nimport glsl from \"./glsl\"\nimport { ProgramInfo } from \"../../programInfo\"\nconst vert = glsl`#version 300 es\n \nlayout(location = 0) in vec4 a_position;\nlayout(location = 1) in vec3 a_normal;\n\nlayout(location = 4) in vec2 a_texcoord;\nlayout(location = 5) in mat4 i_matrix;\n\nuniform mat4 worldMatrix;\nuniform mat4 worldViewProjection;\nuniform vec3 u_lightWorldPosition;\nuniform vec3 u_viewWorldPosition;\n\nout vec3 v_normal;\nout vec2 v_texcoord;\nout vec3 v_surfaceToLight;\nout vec3 v_surfaceToView;\n\nvoid main() {\n\n    vec3 surfaceWorldPosition = (worldMatrix * a_position).xyz;\n    v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;\n\n    vec4 pos =   worldViewProjection * a_position  ;\n    gl_Position = pos;\n\n    v_texcoord = a_texcoord;\n    v_normal = mat3(   worldMatrix ) * a_normal;\n    v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;\n      \n}`\nconst frag = glsl`#version 300 es\nprecision highp float;\n \n\nin vec2 v_texcoord;\n\nin vec3 v_normal;\nin vec3 v_surfaceToView;\nin vec3 v_surfaceToLight;\n\n\n//uniform sampler2D u_texture1;\nuniform float u_shininess;\nuniform vec4 u_color;\nuniform vec4 u_ambientLight;\nout vec4 outColor;\n\n\nvoid main() {\n  \n  vec3 surfaceToLightDirection = normalize(v_surfaceToLight);\n  vec3 surfaceToViewDirection = normalize(v_surfaceToView);\n  vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);\n\n  vec3 normal = normalize(v_normal);\n  float light = dot(v_normal, surfaceToLightDirection);\n  float specular = 0.0;\n  if (light > 0.0) {\n    specular = pow(dot(normal, halfVector), u_shininess);\n  }\n\n  outColor =  u_color;\n  outColor.rgb *= light;\n  outColor.rgb += u_ambientLight.rgb *0.3;\n  \n}\n`\n\nexport default new ProgramInfo(vert, frag)","const glsl = x => x\nexport default glsl","import defaultProgram from \"./Default\";\nimport lightingProgram from \"./Lighting\";\n\nexport {defaultProgram, lightingProgram}","const setCanvasSize = (ctx, width, height) => {\n  ctx.canvas.width = width;\n  ctx.canvas.height = height;\n};\n\nconst makeTexture = (gl, ctx) => {\n  const tex = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, tex);\n\n  gl.texImage2D(\n    gl.TEXTURE_2D,\n    0,\n    gl.RGBA,\n    gl.RGBA,\n    gl.UNSIGNED_BYTE,\n    ctx.canvas\n  );\n  return tex;\n};\nconst makeStripeTexture = (gl, options) => {\n  options = options || {};\n  var width = options.width || 4;\n  var height = options.height || 4;\n  var color1 = options.color1 || \"rgba(1,0,0,0.1)\";\n  var color2 = options.color2 || \"rgba(1,1,1,0.5)\";\n  const ctx = document.createElement(\"canvas\").getContext(\"2d\");\n  setCanvasSize(ctx, width, height);\n\n  ctx.fillStyle = color1;\n  ctx.fillRect(0, 0, width, height);\n  ctx.fillStyle = color2;\n  ctx.fillRect(0, 0, width, height / 2);\n\n  return makeTexture(gl, ctx);\n};\nconst makeStripeImg = (options) => {\n  options = options || {};\n  var width = options.width || 4;\n  var height = options.height || 4;\n  var color1 = options.color1 || \"rgba(1,0,0,0.5)\";\n  var color2 = options.color2 || \"rgba(0,0,1,1)\";\n  const ctx = document.createElement(\"canvas\").getContext(\"2d\");\n  setCanvasSize(ctx, width, height);\n\n  ctx.fillStyle = color1;\n  ctx.fillRect(0, 0, width, height);\n  ctx.fillStyle = color2;\n  ctx.fillRect(0, 0, width, height / 2);\n\n  return ctx.canvas;\n};\nconst makeImgFromSvgXml = (xml, options = {}) => {\n  const img = document.createElement(\"img\");\n  var svg64 = btoa(xml);\n  var b64Start = \"data:image/svg+xml;base64,\";\n  var image64 = b64Start + svg64;\n  img.src = image64;\n\n  const width = options.width || 100;\n  const height = options.height || 100;\n  const x = options.x || 1;\n  const y = options.y || 50;\n\n  const ctx = document.createElement(\"canvas\").getContext(\"2d\");\n  setCanvasSize(ctx, width, height);\n\n  ctx.drawImage(img, x, y, width, height);\n  ctx.fillStyle = \"rgba(0,0,0,1)\";\n  ctx.fillRect(0, 0, width, height);\n  return ctx.img;\n};\nconst setTextureUnits = (gl, texture, unitNum) => {\n  gl.activeTexture(gl.TEXTURE0 + unitNum);\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n};\n\nclass Texture {\n  static makeImgFromSvgXml = makeImgFromSvgXml;\n  constructor(gl) {\n    this.texture = gl.createTexture();\n    this.fromImage = (image) => {\n      gl.bindTexture(gl.TEXTURE_2D, this.texture);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        0,\n        gl.RGBA,\n        gl.RGBA,\n        gl.UNSIGNED_BYTE,\n        image\n      );\n      return this;\n    };\n    this.getTexture = () => this.texture;\n  }\n}\nexport { makeImgFromSvgXml, makeStripeImg, Texture, setTextureUnits };\n","const AABB = require('./src/aabb')\nconst m3 = require('./src/m3')\nconst m4 = require('./src/m4')\nconst {Node , TRS}= require('./src/node')\nconst vector = require('./src/vector')\n\nmodule.exports = {\n    AABB, m3, m4, Node, TRS, vector\n}","class AABB{\n    constructor(min, max){\n        this.min = min\n        this.max = max\n    }\n}\nmodule.exports = AABB","const m3 = {\n    multiply : function(b, a) {\n        var a00 = a[0 * 3 + 0];\n        var a01 = a[0 * 3 + 1];\n        var a02 = a[0 * 3 + 2];\n        var a10 = a[1 * 3 + 0];\n        var a11 = a[1 * 3 + 1];\n        var a12 = a[1 * 3 + 2];\n        var a20 = a[2 * 3 + 0];\n        var a21 = a[2 * 3 + 1];\n        var a22 = a[2 * 3 + 2];\n        var b00 = b[0 * 3 + 0];\n        var b01 = b[0 * 3 + 1];\n        var b02 = b[0 * 3 + 2];\n        var b10 = b[1 * 3 + 0];\n        var b11 = b[1 * 3 + 1];\n        var b12 = b[1 * 3 + 2];\n        var b20 = b[2 * 3 + 0];\n        var b21 = b[2 * 3 + 1];\n        var b22 = b[2 * 3 + 2];\n    \n        return [\n          b00 * a00 + b01 * a10 + b02 * a20,\n          b00 * a01 + b01 * a11 + b02 * a21,\n          b00 * a02 + b01 * a12 + b02 * a22,\n          b10 * a00 + b11 * a10 + b12 * a20,\n          b10 * a01 + b11 * a11 + b12 * a21,\n          b10 * a02 + b11 * a12 + b12 * a22,\n          b20 * a00 + b21 * a10 + b22 * a20,\n          b20 * a01 + b21 * a11 + b22 * a21,\n          b20 * a02 + b21 * a12 + b22 * a22,\n        ];\n      },\n      xRotation: function(angleInRadians) {\n        var c = Math.cos(angleInRadians);\n        var s = Math.sin(angleInRadians);\n     \n        return [\n          1, 0, 0, \n          0, c, s, \n          0, -s, c\n        ];\n      },\n     \n      yRotation: function(angleInRadians) {\n        var c = Math.cos(angleInRadians);\n        var s = Math.sin(angleInRadians);\n     \n        return [\n          c, 0, -s, \n          0, 1, 0, \n          s, 0, c\n        ];\n      },\n     \n      zRotation: function(angleInRadians) {\n        var c = Math.cos(angleInRadians);\n        var s = Math.sin(angleInRadians);\n     \n        return [\n           c, s, 0, \n          -s, c, 0,\n           0, 0, 1\n        ];\n      },\n      m3Tom4 : function(m){\n        const dst = new Float32Array(16)\n        dst[ 0] = m[0]\n        dst[ 1] = m[1]\n        dst[ 2] = m[2]\n        dst[ 3] = 0\n        dst[ 4] = m[3]\n        dst[ 5] = m[4]\n        dst[ 6] = m[5]\n        dst[ 7] = 0\n        dst[ 8] = m[6]\n        dst[ 9] = m[7]\n        dst[10] = m[8]\n        dst[11] = 0\n        dst[12] = 0\n        dst[13] = 0\n        dst[14] = 0\n        dst[15] = 1\n        return dst\n      },\n      xRotate: function(m, angleInRadians) {\n        return m3.multiply(m, m3.xRotation(angleInRadians));\n      },\n     \n      yRotate: function(m, angleInRadians) {\n        return m3.multiply(m, m3.yRotation(angleInRadians));\n      },\n     \n      zRotate: function(m, angleInRadians) {\n        return m3.multiply(m, m3.zRotation(angleInRadians));\n      },\n      transformPoint : function(m, v, dst) {\n        dst = dst || new Float32Array(3);\n        var v0 = v[0];\n        var v1 = v[1];\n        var v2 = v[2];\n        \n    \n        dst[0] = (v0 * m[0 * 3 + 0] + v1 * m[1 * 3 + 0] + v2 * m[2 * 3 + 0]  ) \n        dst[1] = (v0 * m[0 * 3 + 1] + v1 * m[1 * 3 + 1] + v2 * m[2 * 3 + 1]  ) \n        dst[2] = (v0 * m[0 * 3 + 2] + v1 * m[1 * 3 + 2] + v2 * m[2 * 3 + 2] ) \n    \n        return dst;\n      },\n      identity : function() {\n        return [\n          1, 0, 0,\n          0, 1, 0,\n          0, 0, 1,\n        ];\n      },\n      transpose : function(m){\n         \n          dst = new Float32Array(9)\n          dst[0] = m[0]\n          dst[1] = m[3]\n          dst[2] = m[6]\n          dst[3] = m[1]\n          dst[4] = m[4]\n          dst[5] = m[7]\n          dst[6] = m[2]\n          dst[7] = m[5]\n          dst[8] = m[8]\n          return dst\n      },\n      scaling : function(sx,sy,sz){\n        return new Float32Array([\n                    sx, 0, 0,\n                    0, sy, 0,\n                    0,  0, sz\n              ])\n      },\n      scale : function(m, sx,sy,sz){\n        return m3.multiply(m, m3.scaling(sx, sy, sz))\n      },\n      /*\n      0 1 2\n      3 4 5\n      6 7 8\n      */\n      inverse : function(m){\n       const det = m[0] * m[4] * m[8] + \n                   m[2] * m[3] * m[7] +\n                   m[1] * m[5] * m[6] -\n                   m[2] * m[4] * m[6] -\n                   m[0] * m[5] * m[7] -\n                   m[8] * m[3] * m[2] \n        const dst = new Float32Array(9)\n        dst[0] = (m[4] * m[8] - m[7] * m[5]) / det\n        dst[1] = (m[3] * m[8] - m[6] * m[5]) / det\n        dst[2] = (m[3] * m[7] - m[6] * m[4]) / det\n        dst[3] = (m[1] * m[8] - m[2] * m[7]) / det\n        dst[4] = (m[0] * m[8] - m[2] * m[6]) / det\n        dst[5] = (m[0] * m[7] - m[1] * m[6]) / det\n        dst[6] = (m[1] * m[5] - m[2] * m[4]) / det\n        dst[7] = (m[0] * m[5] - m[2] * m[3]) / det\n        dst[8] = (m[0] * m[4] - m[1] * m[4]) / det\n        \n      },\n      toString(m){\n        return m.reduce((acc,el,idx) => (idx) % 3 === 0 ? acc += '\\n' + el : acc += ' ' + el )\n      },\n      dot(v1,v2){\n        return v1[0]*v2[0] + v1[1]*v2[1] + v1[2] * v2[2]\n      }\n}\nmodule.exports = m3","const MatType = Float32Array\nconst m4 = {\n    multiply: function(a, b, dst) {\n      dst = dst || new MatType(16);\n      var a00 = a[0 * 4 + 0];\n      var a01 = a[0 * 4 + 1];\n      var a02 = a[0 * 4 + 2];\n      var a03 = a[0 * 4 + 3];\n      var a10 = a[1 * 4 + 0];\n      var a11 = a[1 * 4 + 1];\n      var a12 = a[1 * 4 + 2];\n      var a13 = a[1 * 4 + 3];\n      var a20 = a[2 * 4 + 0];\n      var a21 = a[2 * 4 + 1];\n      var a22 = a[2 * 4 + 2];\n      var a23 = a[2 * 4 + 3];\n      var a30 = a[3 * 4 + 0];\n      var a31 = a[3 * 4 + 1];\n      var a32 = a[3 * 4 + 2];\n      var a33 = a[3 * 4 + 3];\n      var b00 = b[0 * 4 + 0];\n      var b01 = b[0 * 4 + 1];\n      var b02 = b[0 * 4 + 2];\n      var b03 = b[0 * 4 + 3];\n      var b10 = b[1 * 4 + 0];\n      var b11 = b[1 * 4 + 1];\n      var b12 = b[1 * 4 + 2];\n      var b13 = b[1 * 4 + 3];\n      var b20 = b[2 * 4 + 0];\n      var b21 = b[2 * 4 + 1];\n      var b22 = b[2 * 4 + 2];\n      var b23 = b[2 * 4 + 3];\n      var b30 = b[3 * 4 + 0];\n      var b31 = b[3 * 4 + 1];\n      var b32 = b[3 * 4 + 2];\n      var b33 = b[3 * 4 + 3];\n      dst[ 0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;\n      dst[ 1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;\n      dst[ 2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;\n      dst[ 3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;\n      dst[ 4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;\n      dst[ 5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;\n      dst[ 6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;\n      dst[ 7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;\n      dst[ 8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;\n      dst[ 9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;\n      dst[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;\n      dst[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;\n      dst[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;\n      dst[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;\n      dst[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;\n      dst[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;\n      return dst;\n    },\n      \n      translation: function(tx, ty, tz) {\n        return [\n           1,  0,  0,  0,\n           0,  1,  0,  0,\n           0,  0,  1,  0,\n           tx, ty, tz, 1,\n        ];\n      },\n     \n      xRotation: function(angleInRadians) {\n        var c = Math.cos(angleInRadians);\n        var s = Math.sin(angleInRadians);\n     \n        return [\n          1, 0, 0, 0,\n          0, c, s, 0,\n          0, -s, c, 0,\n          0, 0, 0, 1,\n        ];\n      },\n     \n      yRotation: function(angleInRadians) {\n        var c = Math.cos(angleInRadians);\n        var s = Math.sin(angleInRadians);\n     \n        return [\n          c, 0, -s, 0,\n          0, 1, 0, 0,\n          s, 0, c, 0,\n          0, 0, 0, 1,\n        ];\n      },\n     \n      zRotation: function(angleInRadians) {\n        var c = Math.cos(angleInRadians);\n        var s = Math.sin(angleInRadians);\n     \n        return [\n           c, s, 0, 0,\n          -s, c, 0, 0,\n           0, 0, 1, 0,\n           0, 0, 0, 1,\n        ];\n      },\n     \n      scaling: function(sx, sy, sz) {\n        return [\n          sx, 0,  0,  0,\n          0, sy,  0,  0,\n          0,  0, sz,  0,\n          0,  0,  0,  1,\n        ];\n      },\n      translate: function(m, tx, ty, tz) {\n        return m4.multiply(m, m4.translation(tx, ty, tz));\n      },\n     \n      xRotate: function(m, angleInRadians) {\n        return m4.multiply(m, m4.xRotation(angleInRadians));\n      },\n     \n      yRotate: function(m, angleInRadians) {\n        return m4.multiply(m, m4.yRotation(angleInRadians));\n      },\n     \n      zRotate: function(m, angleInRadians) {\n        return m4.multiply(m, m4.zRotation(angleInRadians));\n      },\n     \n      scale: function(m, sx, sy, sz) {\n        return m4.multiply(m, m4.scaling(sx, sy, sz));\n      },\n      makeOrt : function(v){\n        const o = [0,0,0]\n        const norm = Math.sqrt( v[0] * v[0] + v[1] * v[1] + v[2]*v[2] )\n        o[0] = v[0] / norm\n        o[1] = v[1] / norm\n        o[2] = v[2] / norm\n        return o\n      },\n      projection: function(width, height, depth) {\n        // Эта матрица переворачивает Y, чтобы 0 был наверху\n        return [\n           2 / width, 0, 0, 0,\n           0, -2 / height, 0, 0,\n           0, 0, 2 / depth, 0,\n          -1, 1, 0, 1,\n        ];\n      },\n      perspective: function(fieldOfViewInRadians, aspect, near, far) {\n        var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);\n        var rangeInv = 1.0 / (near - far);\n     \n        return [\n          f / aspect, 0, 0, 0,\n          0, f, 0, 0,\n          0, 0, (near + far) * rangeInv, -1,\n          0, 0, near * far * rangeInv * 2, 0\n        ];\n      },\n      inverse: function(m) {\n        var m00 = m[0 * 4 + 0];\n        var m01 = m[0 * 4 + 1];\n        var m02 = m[0 * 4 + 2];\n        var m03 = m[0 * 4 + 3];\n        var m10 = m[1 * 4 + 0];\n        var m11 = m[1 * 4 + 1];\n        var m12 = m[1 * 4 + 2];\n        var m13 = m[1 * 4 + 3];\n        var m20 = m[2 * 4 + 0];\n        var m21 = m[2 * 4 + 1];\n        var m22 = m[2 * 4 + 2];\n        var m23 = m[2 * 4 + 3];\n        var m30 = m[3 * 4 + 0];\n        var m31 = m[3 * 4 + 1];\n        var m32 = m[3 * 4 + 2];\n        var m33 = m[3 * 4 + 3];\n        var tmp_0  = m22 * m33;\n        var tmp_1  = m32 * m23;\n        var tmp_2  = m12 * m33;\n        var tmp_3  = m32 * m13;\n        var tmp_4  = m12 * m23;\n        var tmp_5  = m22 * m13;\n        var tmp_6  = m02 * m33;\n        var tmp_7  = m32 * m03;\n        var tmp_8  = m02 * m23;\n        var tmp_9  = m22 * m03;\n        var tmp_10 = m02 * m13;\n        var tmp_11 = m12 * m03;\n        var tmp_12 = m20 * m31;\n        var tmp_13 = m30 * m21;\n        var tmp_14 = m10 * m31;\n        var tmp_15 = m30 * m11;\n        var tmp_16 = m10 * m21;\n        var tmp_17 = m20 * m11;\n        var tmp_18 = m00 * m31;\n        var tmp_19 = m30 * m01;\n        var tmp_20 = m00 * m21;\n        var tmp_21 = m20 * m01;\n        var tmp_22 = m00 * m11;\n        var tmp_23 = m10 * m01;\n    \n        var t0 = (tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31) -\n            (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);\n        var t1 = (tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31) -\n            (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);\n        var t2 = (tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31) -\n            (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);\n        var t3 = (tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21) -\n            (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);\n    \n        var d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);\n    \n        return [\n          d * t0,\n          d * t1,\n          d * t2,\n          d * t3,\n          d * ((tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30) -\n                (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30)),\n          d * ((tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30) -\n                (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30)),\n          d * ((tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30) -\n                (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30)),\n          d * ((tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20) -\n                (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20)),\n          d * ((tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33) -\n                (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33)),\n          d * ((tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33) -\n                (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33)),\n          d * ((tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33) -\n                (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33)),\n          d * ((tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23) -\n                (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23)),\n          d * ((tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12) -\n                (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22)),\n          d * ((tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22) -\n                (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02)),\n          d * ((tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02) -\n                (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12)),\n          d * ((tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12) -\n                (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02))\n        ];\n      },\n      lookAt: function(cameraPosition, target, up) {\n        var zAxis = normalize(\n            subtractVectors(cameraPosition, target));\n        var xAxis = normalize(cross(up, zAxis));\n        var yAxis = normalize(cross(zAxis, xAxis));\n     \n        return [\n           xAxis[0], xAxis[1], xAxis[2], 0,\n           yAxis[0], yAxis[1], yAxis[2], 0,\n           zAxis[0], zAxis[1], zAxis[2], 0,\n           cameraPosition[0],\n           cameraPosition[1],\n           cameraPosition[2],\n           1,\n        ];\n      },\n      copy:function(src){\n        \n          const dst = new MatType(16);\n      \n          dst[ 0] = src[ 0];\n          dst[ 1] = src[ 1];\n          dst[ 2] = src[ 2];\n          dst[ 3] = src[ 3];\n          dst[ 4] = src[ 4];\n          dst[ 5] = src[ 5];\n          dst[ 6] = src[ 6];\n          dst[ 7] = src[ 7];\n          dst[ 8] = src[ 8];\n          dst[ 9] = src[ 9];\n          dst[10] = src[10];\n          dst[11] = src[11];\n          dst[12] = src[12];\n          dst[13] = src[13];\n          dst[14] = src[14];\n          dst[15] = src[15];\n      \n          return dst;\n        \n      \n      },\n      vectorSum : function(v1,v2){\n        const vector = [0,0,0]\n        vector[0] = v1[0] + v2[0]\n        vector[1] = v1[1] + v2[1]\n        vector[2] = v1[2] + v2[2]\n        return vector\n      },\n      cross  : function(a, b) {\n        return [a[1] * b[2] - a[2] * b[1],\n                a[2] * b[0] - a[0] * b[2],\n                a[0] * b[1] - a[1] * b[0]];\n      },\n      vectorScalarProduct(a,s){\n        let v = [0,0,0]\n\n        v[0] = a[0] * s\n        v[1] = a[1] * s\n        v[2] = a[2] * s\n        if(isNaN(v[0])|| isNaN(v[2]) || isNaN(v[2])) return [0,0,0]\n        return v\n      },\n\n      scalarProduct : function(v1,v2){\n        let a = v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2]\n        \n        return a\n      },\n      dot(v1,v2){\n        return v1[0]*v2[0] + v1[1]*v2[1] + v1[2] * v2[2]\n      },\n      isNullVector: function(v){\n        \n        return !v[0]&&!v[1]&&!v[2]\n      },\n      getVectorLength(v){\n        return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2])\n      },\n      transformPoint : function(m, v, dst) {\n        dst = dst || new MatType(3);\n        var v0 = v[0];\n        var v1 = v[1];\n        var v2 = v[2];\n        var d = v0 * m[0 * 4 + 3] + v1 * m[1 * 4 + 3] + v2 * m[2 * 4 + 3] + m[3 * 4 + 3];\n    \n        dst[0] = (v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0] + m[3 * 4 + 0]) / d;\n        dst[1] = (v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1] + m[3 * 4 + 1]) / d;\n        dst[2] = (v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2] + m[3 * 4 + 2]) / d;\n    \n        return dst;\n      },\n      normalize : function(v, dst) {\n        dst = dst || new MatType(3);\n        var length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\n        // make sure we don't divide by 0.\n        if (length > 0.00001) {\n          dst[0] = v[0] / length;\n          dst[1] = v[1] / length;\n          dst[2] = v[2] / length;\n        }\n        return dst;\n      },\n      identity: function() {\n        dst = new MatType(16);\n        dst[ 0] = 1;\n        dst[ 1] = 0;\n        dst[ 2] = 0;\n        dst[ 3] = 0;\n        dst[ 4] = 0;\n        dst[ 5] = 1;\n        dst[ 6] = 0;\n        dst[ 7] = 0;\n        dst[ 8] = 0;\n        dst[ 9] = 0;\n        dst[10] = 1;\n        dst[11] = 0;\n        dst[12] = 0;\n        dst[13] = 0;\n        dst[14] = 0;\n        dst[15] = 1;\n    \n        return dst;\n      },\n      m3Tom4 : function(m){\n        const dst = new MatType(16)\n        dst[ 0] = m[0]\n        dst[ 1] = m[1]\n        dst[ 2] = m[2]\n        dst[ 3] = 0\n        dst[ 4] = m[3]\n        dst[ 5] = m[4]\n        dst[ 6] = m[5]\n        dst[ 7] = 0\n        dst[ 8] = m[6]\n        dst[ 9] = m[7]\n        dst[10] = m[8]\n        dst[11] = 0\n        dst[12] = 0\n        dst[13] = 0\n        dst[14] = 0\n        dst[15] = 1\n        return dst\n      },\n      m4Tom3 : function(m){\n        const dst = new MatType(9)\n        dst[ 0] = m[0]\n        dst[ 1] = m[1]\n        dst[ 2] = m[2]\n        dst[ 3] = m[4]\n        dst[ 4] = m[5]\n        dst[ 5] = m[6]\n        dst[ 6] = m[8]\n        dst[ 7] = m[9]\n        dst[ 8] = m[10]\n        return dst\n      },\n      toString(m){\n        return m.reduce((acc,el,idx) => (idx) % 4 === 0 ? acc += '\\n' + el : acc += ' ' + el )\n      },\n      transpose: function(m) {\n        return [\n          m[0], m[4], m[8], m[12],\n          m[1], m[5], m[9], m[13],\n          m[2], m[6], m[10], m[14],\n          m[3], m[7], m[11], m[15],\n        ];\n      },\n      fromQuaternion : q => {\n        const a11 = 1 - 2 * (q[1] * q[1] + q[2] * q[2])\n        const a12 = 2 * (q[0] * q[1] - q[2] * q[3])\n        const a13 = 2 * (q[0] * q[2] + q[1] * q[3])\n        const a21 = 2 * (q[0] * q[1] + q[2] * q[3])\n        const a22 = 1 - 2 * (q[0] * q[0] + q[2] * q[2])\n        const a23 = 2 * (q[1] * q[2] - q[0] * q[3])\n        const a31 = 2 * (q[0] * q[2] - q[1] * q[3])\n        const a32 = 2 * (q[1] * q[2] + q[0] * q[3])\n        const a33 = 1 - 2 * (q[0] * q[0] + q[1] * q[1])\n        return [\n          a11, a12, a13, 0,\n          a21, a22, a23, 0,\n          a31, a32, a33, 0,\n          0,   0,   0,   1,  \n        ]\n      }\n    };\n    function makeZToWMatrix(fudgeFactor) {\n      return [\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, fudgeFactor,\n        0, 0, 0, 1,\n      ];\n    }\n    function cross(a, b) {\n      return [a[1] * b[2] - a[2] * b[1],\n              a[2] * b[0] - a[0] * b[2],\n              a[0] * b[1] - a[1] * b[0]];\n    }\n    function subtractVectors(a, b) {\n      return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];\n    }\n    \nmodule.exports = m4","\nconst m4 = require('./m4')\nclass TRS{\n    constructor(translation, rotation, scale){\n        this.translation = translation\n        this.rotation = rotation\n        this.scale = scale\n    }\n    getMatrix(m) {\n\n        let dst = m || m4.identity();\n        var t = this.translation;\n        var r = this.rotation;\n        var s = this.scale;\n        const sin = Math.sin(r[3] / 2)\n        const cos = Math.cos(r[3] / 2)\n        dst = m4.translate(dst,t[0], t[1], t[2]);\n\n        dst = m4.multiply(dst, m4.fromQuaternion(r))\n        \n        dst = m4.scale(dst, s[0], s[1], s[2]);\n        return dst;\n      };\n    getRMatrix(){\n        let dst = m4.identity();\n        var r = this.rotation;\n        dst = m4.xRotate(dst, r[0]);\n        dst = m4.yRotate(dst, r[1]);\n        dst = m4.zRotate(dst, r[2]);\n        return dst\n    }\n}\nclass Node{\n    constructor( name, trs = new TRS()){\n        \n        this.worldMatrix = m4.identity()\n        this.originMatrix = m4.identity()\n        this.parent = null\n        this.children = []\n        this.trs = trs\n        this.name = name\n        this.parts = []\n    }\n    setParent(parent){\n        if (this.parent) {\n            const ndx = this.parent.children.indexOf(this);\n            if (ndx >= 0) {\n              this.parent.children.splice(ndx, 1);\n            }\n          }\n          if (parent) {\n            parent.children.push(this);\n          }\n          this.parent = parent;\n    }\n    updateWorldMatrix(parentWorldMatrix){\n        \n        let matrix = this.trs.getMatrix()\n        \n        if (parentWorldMatrix) {\n          matrix = m4.multiply(parentWorldMatrix, matrix);\n        }\n        \n        this.worldMatrix = matrix\n        this.children.forEach((child) => {\n          child.updateWorldMatrix([...matrix]);\n        })\n    }\n    updatePartsList(){\n        const iter = (node,arr) => {\n            arr.push(node)\n            node.children.forEach(child => iter(child,arr))\n        }\n        iter(this, this.parts)\n    }\n    \n    \n    \n}\n\n\nmodule.exports = {Node, TRS}","const dot = (a, b) => a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\nconst cross = (a, b) => {\n    const res = [\n                            a[1] * b[2] - b[1] * a[2],\n                            a[2] * b[0] - b[2] * a[0],\n                            a[0] * b[1] - b[0] * a[1]    \n                    ]\n    if(isNaNvec(a) || isNaNvec(b)){\n        console.log(a, b)\n        throw new Error('args is NaN : ,')\n    }\n    return res\n}          \nconst scale = (a, scalar) => [a[0] * scalar, a[1] * scalar, a[2] * scalar]\nconst sum = (a, b) => [a[0] + b[0], a[1] + b[1], a[2] + b[2]]\nconst diff = (a, b) => [a[0] - b[0], a[1] - b[1], a[2] - b[2]]\nconst norm = a => Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2])\nconst normSq = a => a[0] * a[0] + a[1] * a[1] + a[2] * a[2]\nconst normalize = a => {\n    const length = norm(a)\n    if(length === 0) return a\n    return [a[0] / length, a[1] / length, a[2] / length]\n}\nconst isNull = a => a[0]*a[0] + a[1] * a[1] + a[2] * a[2] === 0\n\nconst isEqual = (a, b) => a[0] == b[0] && a[1] == b[1] && a[2] == b[2]\nconst chkV = (v) =>{\n    if(isNaNvec(v)){\n        console.log(v)\n        throw new Error('NaN Vec')\n    }\n}\n\nconst findFurthestPoint = (a,b,c) => {\n    const AB = normSq(diff(a, b))\n    const AC = normSq(diff(a, c))\n    const BC = normSq(diff(c, b))\n    if(AB < AC){\n        if(AB < BC) return c\n        return b\n    }\n    else{\n        if(AC < BC) return b\n        else return a\n    }\n}\nconst distanceFromLine = (a,b,c) =>{\n    const ac = diff(c, a)\n    const ab = diff(b, a)\n    const k = dot(ab,ac) / normSq(ab)\n    const h = sum(a, scale(ab, k))\n    return normSq(diff(c, h))\n}\n\n\nconst isNaNvec = v => isNaN(v[0] + v[1] + v[2]) || (v[0] + v[1] + v[2] === Infinity) || (v[0] + v[1] + v[2] === -Infinity)\nconst _dot = (a, b) =>{\n    if(isNaNvec(a) || isNaNvec(b)){\n        console.log(a, b)\n        throw new Error('args is NaN : ,')\n    }\n    return dot(a, b)\n}\nconst _cross = (a, b) =>{\n    if(isNaNvec(a) || isNaNvec(b)){\n        console.log(a, b)\n        throw new Error('args is NaN : ,')\n    }\n    const res = cross(a, b)  \n    if(isNaNvec(res)){\n        console.log(a, b)\n        throw new Error('get NaN : ,')\n    }\n    return res \n}\nconst _sum = (a, b) =>{\n    if(isNaNvec(a) || isNaNvec(b)){\n        console.log(a, b)\n        throw new Error('args is NaN : ,')\n    }\n    const res = sum(a, b)  \n    if(isNaNvec(res)){\n        console.log(a, b)\n        throw new Error('get NaN : ,')\n    }\n    return res \n}\nconst _diff = (a, b) =>{\n    if(isNaNvec(a) || isNaNvec(b)){\n        console.log(a, b)\n        throw new Error('args is NaN : ,')\n    }\n    const res = diff(a, b)  \n    if(isNaNvec(res)){\n        console.log(a, b)\n        throw new Error('get NaN : ,')\n    }\n    return res    \n}\nconst _scale = (a, scalar) =>{\n    if(isNaNvec(a) || isNaN(scalar)){\n        console.log(a, scalar)\n        throw new Error('args is NaN : ,')\n    }\n    const res = scale(a, scalar)  \n    if(isNaNvec(res)){\n        console.log(a, scalar)\n        throw new Error('get NaN : ,')\n    }\n    return res \n}\nconst _normalize = a =>{\n    if(isNaNvec(a)){\n        console.log(a)\n        throw new Error('args is NaN : ,')\n    }\n    const res = normalize(a)  \n    if(isNaNvec(res)){\n        console.log(a)\n        throw new Error('get NaN : ,')\n    }\n    return res \n}\nmodule.exports = {chkV, dot : _dot, cross : _cross, scale : _scale, sum : _sum, diff : _diff, normalize : _normalize, norm, normSq, isNull, findFurthestPoint, distanceFromLine, isEqual}","let distSq = (x, y) => {\r\n  return x.map((e, i) => e - y[i]).reduce((acc, e) => (acc += e ** 2), 0);\r\n};\r\n\r\nconst GaussSeidel = (A, b, n, eps) => {\r\n  let x = new Array(n).fill(0);\r\n  let conv = false,\r\n    maxIter = 64;\r\n  let x_new = [];\r\n  while (!conv && maxIter > 0) {\r\n    maxIter--;\r\n    x_new = [...x];\r\n    for (let i = 0; i < n; i++) {\r\n      let s = 0;\r\n      for (let j = 0; j < i; j++) {\r\n        s += A[i * n + j] * x_new[j];\r\n      }\r\n      for (let j = i + 1; j < n; j++) {\r\n        s += A[i * n + j] * x[j];\r\n      }\r\n      x_new[i] = (b[i] - s) / A[i * n + i];\r\n    }\r\n\r\n    conv = distSq(x, x_new) < eps;\r\n    x = [...x_new];\r\n  }\r\n  return x_new;\r\n};\r\nexport { GaussSeidel };\r\n","import { vector, m4, m3, AABB } from \"math\";\r\n\r\nconst { scale, sum, diff } = vector;\r\n\r\nconst xAxis = [1, 0, 0];\r\nconst yAxis = [0, 1, 0];\r\nconst zAxis = [0, 0, 1];\r\nconst xAxisNegative = scale(xAxis, -1);\r\nconst yAxisNegative = scale(yAxis, -1);\r\nconst zAxisNegative = scale(zAxis, -1);\r\n\r\nclass Collider {\r\n  constructor() {\r\n    this.Rmatrix = m3.identity();\r\n    this.pos = [];\r\n    this.scale = [1, 1, 1];\r\n    this.RS = m3.identity();\r\n    this.RSinverse = m3.identity();\r\n    this.pos = [0, 0, 0];\r\n  }\r\n  translate(v) {\r\n    this.pos = sum(this.pos, v);\r\n  }\r\n  rotate(v) {\r\n    this.RSmatrix = m3.xRotate(this.RSmatrix, v[0]);\r\n    this.RSmatrix = m3.yRotate(this.RSmatrix, v[1]);\r\n    this.RSmatrix = m3.zRotate(this.RSmatrix, v[2]);\r\n    this.RmatrixInverse = m3.transpose(this.RSmatrix);\r\n  }\r\n  getAABB() {\r\n    const maxX = this.support(xAxis)[0];\r\n    const maxY = this.support(yAxis)[1];\r\n    const maxZ = this.support(zAxis)[2];\r\n\r\n    const minX = this.support(xAxisNegative)[0];\r\n    const minY = this.support(yAxisNegative)[1];\r\n    const minZ = this.support(zAxisNegative)[2];\r\n    return new AABB([minX, minY, minZ], [maxX, maxY, maxZ]);\r\n  }\r\n  setRSMat3(m) {\r\n    this.RSmatrix = m;\r\n    this.RSmatrixInverse = m3.transpose(m);\r\n  }\r\n  setTRSMat4(m) {\r\n    this.RSmatrix = m4.m4Tom3(m);\r\n    this.pos[0] = m[12];\r\n    this.pos[1] = m[13];\r\n    this.pos[2] = m[14];\r\n  }\r\n  getTRSMat4() {\r\n    const m = m4.m3Tom4(this.RSmatrix);\r\n    m[12] = this.pos[0];\r\n    m[13] = this.pos[1];\r\n    m[14] = this.pos[2];\r\n    m[15] = 1;\r\n    return m;\r\n  }\r\n  localToGlobal(v) {\r\n    let global = m3.transformPoint(this.RSmatrix, v);\r\n    return sum(this.pos, global);\r\n  }\r\n}\r\n\r\nclass Box {\r\n  constructor(a = 1, b = 1, c = 1) {\r\n    this.min = [-a / 2, -b / 2, -c / 2];\r\n    this.max = [a / 2, b / 2, c / 2];\r\n    this.Rmatrix = m3.identity();\r\n    this.RmatrixInverse = m3.identity();\r\n    this.RS = m3.identity();\r\n    this.pos = [0, 0, 0];\r\n    this.points = [\r\n      [-a, -b, -c],\r\n      [a, -b, -c],\r\n      [a, b, -c],\r\n      [-a, b, -c],\r\n      [-a, -b, c],\r\n      [a, -b, c],\r\n      [a, b, c],\r\n      [-a, b, c],\r\n    ];\r\n    this.indices = [\r\n      [3, 2, 1, 0], // -z\r\n      [4, 5, 6, 7], // +z\r\n      [5, 4, 0, 1], // -y\r\n      [2, 3, 7, 6], // +y\r\n      [0, 4, 7, 3], // -x\r\n      [1, 2, 6, 5], // +x\r\n    ];\r\n    this.normals = [\r\n      [0, 0, -1],\r\n      [0, 0, 1],\r\n      [0, -1, 0],\r\n      [0, 1, 0],\r\n      [-1, 0, 0],\r\n      [1, 0, 0],\r\n    ];\r\n  }\r\n  getNormalsGlobal() {\r\n    return this.normals.map((n) => m3.transformPoint(this.Rmatrix, n));\r\n  }\r\n  getAABB() {\r\n    const maxX = this.support(xAxis)[0];\r\n    const maxY = this.support(yAxis)[1];\r\n    const maxZ = this.support(zAxis)[2];\r\n\r\n    const minX = this.support(xAxisNegative)[0];\r\n    const minY = this.support(yAxisNegative)[1];\r\n    const minZ = this.support(zAxisNegative)[2];\r\n    return new AABB([minX, minY, minZ], [maxX, maxY, maxZ]);\r\n  }\r\n  translate(t) {\r\n    this.pos = sum(this.pos, t);\r\n  }\r\n  rotate(r) {\r\n    this.Rmatrix = m3.xRotate(this.Rmatrix, r[0]);\r\n    this.Rmatrix = m3.yRotate(this.Rmatrix, r[1]);\r\n    this.Rmatrix = m3.zRotate(this.Rmatrix, r[2]);\r\n\r\n    this.RmatrixInverse = m3.transpose(this.Rmatrix);\r\n  }\r\n  setRmatrix(matrix) {\r\n    this.Rmatrix = matrix;\r\n    this.RmatrixInverse = m3.transpose(matrix);\r\n  }\r\n  support(dir) {\r\n    const _dir = m3.transformPoint(this.RmatrixInverse, dir);\r\n\r\n    const res = [0, 0, 0];\r\n\r\n    res[0] = _dir[0] > 0 ? this.max[0] : this.min[0];\r\n    res[1] = _dir[1] > 0 ? this.max[1] : this.min[1];\r\n    res[2] = _dir[2] > 0 ? this.max[2] : this.min[2];\r\n\r\n    const sup = m4.transformPoint(this.getM4(), res);\r\n\r\n    return sup;\r\n  }\r\n  getInverseInertiaTensor(mass) {\r\n    const i1 =\r\n      (mass / 12) * (this.max[1] * this.max[1] + this.max[2] * this.max[2]);\r\n    const i2 =\r\n      (mass / 12) * (this.max[0] * this.max[0] + this.max[2] * this.max[2]);\r\n    const i3 =\r\n      (mass / 12) * (this.max[0] * this.max[0] + this.max[1] * this.max[1]);\r\n\r\n    const m = new Float32Array([1 / i1, 0, 0, 0, 1 / i2, 0, 0, 0, 1 / i3]);\r\n\r\n    return m3.multiply(m3.multiply(this.Rmatrix, m), this.RmatrixInverse);\r\n  }\r\n  getM4() {\r\n    const m = m4.m3Tom4(this.Rmatrix);\r\n    m[12] = this.pos[0];\r\n    m[13] = this.pos[1];\r\n    m[14] = this.pos[2];\r\n    m[15] = 1;\r\n    return m;\r\n  }\r\n  localToGlobal(v) {\r\n    let global = m3.transformPoint(this.Rmatrix, v);\r\n    return sum(this.pos, global);\r\n  }\r\n}\r\n\r\nexport { Box };\r\n","import { vector, m3 } from \"math\";\r\nimport { GaussSeidel } from \"./GSsolver\";\r\n\r\nconst { sum, diff, scale, cross, dot, normalize, norm, normSq } = vector;\r\n\r\nconst tol = 0.01;\r\nconst tol2 = 0.00001;\r\nconst numIterations = 1;\r\nconst numPosIterations = 1;\r\n\r\nconst clamp = (v, min, max) => {\r\n  if (v > min) {\r\n    if (v < max) return v;\r\n    else return max;\r\n  }\r\n  return min;\r\n};\r\n\r\nconst getManifoldSystem = (manifold) => {\r\n  const body1 = manifold.body1;\r\n  const body2 = manifold.body2;\r\n\r\n  const M1 = body1.inverseMass;\r\n  const I1 = body1.inverseInertia;\r\n  const M2 = body2.inverseMass;\r\n  const I2 = body2.inverseInertia;\r\n  const contacts = manifold.contacts;\r\n  let n = contacts.length;\r\n  let A = [];\r\n  const JV = [];\r\n  for (let i = 0; i < n; i++) {\r\n    const rowNum = i * n;\r\n    const JM = [\r\n      scale(contacts[i].J[0], M1),\r\n      m3.transformPoint(I1, contacts[i].J[1]),\r\n      scale(contacts[i].J[2], M2),\r\n      m3.transformPoint(I2, contacts[i].J[3]),\r\n    ];\r\n    for (let j = 0; j < n; j++) {\r\n      if (i === j) {\r\n        A[rowNum + j] = contacts[i].effMass;\r\n        continue;\r\n      }\r\n      A[rowNum + j] =\r\n        dot(JM[0], contacts[j].J[0]) +\r\n        dot(JM[1], contacts[j].J[1]) +\r\n        dot(JM[2], contacts[j].J[2]) +\r\n        dot(JM[3], contacts[j].J[3]);\r\n    }\r\n    JV.push(\r\n      -dot(contacts[i].J[0], body1.velocity) -\r\n        dot(contacts[i].J[1], body1.angularV) -\r\n        dot(contacts[i].J[2], body2.velocity) -\r\n        dot(contacts[i].J[3], body2.angularV)\r\n    );\r\n  }\r\n  return { A, JV };\r\n};\r\nconst blockSolver = (manifold, deltaTime) => {\r\n  const body1 = manifold.body1;\r\n  const body2 = manifold.body2;\r\n\r\n  const contacts = manifold.contacts;\r\n  let n = contacts.length;\r\n\r\n  const { A, JV } = getManifoldSystem(manifold);\r\n  for (let i = 0; i < n; i++) {\r\n    // JV[i] += Math.max(0,contacts[i].penDepth-tol)/deltaTime * 0.25\r\n  }\r\n  const lambda = GaussSeidel(A, JV, n, 0.000001);\r\n\r\n  for (let i = 0; i < n; i++) {\r\n    body1.applyImpulse(scale(contacts[i].J[0], lambda[i]), contacts[i].ra);\r\n    body2.applyImpulse(scale(contacts[i].J[2], lambda[i]), contacts[i].rb);\r\n  }\r\n  return lambda;\r\n};\r\nconst frictionSolver = (contact, lambda, body1, body2) => {\r\n  contact.relVelocity = sum(body2.velocity, cross(body2.angularV, contact.rb));\r\n  contact.relVelocity = diff(contact.relVelocity, body1.velocity);\r\n  contact.relVelocity = diff(\r\n    contact.relVelocity,\r\n    cross(body1.angularV, contact.ra)\r\n  );\r\n\r\n  const mu = body1.friction + body1.friction;\r\n  let fImpulse1 = -dot(contact.relVelocity, contact.fDir1) / contact.fEffMass1;\r\n  fImpulse1 = clamp(fImpulse1, -lambda * mu, lambda * mu);\r\n\r\n  let fImpulse2 = -dot(contact.relVelocity, contact.fDir2) / contact.fEffMass2;\r\n  fImpulse2 = clamp(fImpulse2, -lambda * mu, lambda * mu);\r\n\r\n  contact.accFI1 += fImpulse1;\r\n  contact.accFI2 += fImpulse2;\r\n\r\n  let fVec = sum(\r\n    scale(contact.fDir1, fImpulse1),\r\n    scale(contact.fDir2, fImpulse2)\r\n  );\r\n\r\n  body1.applyImpulse(scale(fVec, -1), contact.ra);\r\n  body2.applyImpulse(fVec, contact.rb);\r\n};\r\nfunction solveCollision(manifold, deltaTime) {\r\n  const body1 = manifold.body1;\r\n  const body2 = manifold.body2;\r\n  const contacts = manifold.contacts;\r\n  if (contacts.length > 1) {\r\n    const lambda = blockSolver(manifold, deltaTime);\r\n    const n = lambda.length;\r\n    for (let i = 0; i < n; i++) {\r\n      frictionSolver(contacts[i], lambda[i], body1, body2);\r\n    }\r\n    return;\r\n  }\r\n  for (let j = 0; j < numIterations; j++) {\r\n    for (let i = 0, n = manifold.contacts.length; i < n; i++) {\r\n      const contact = manifold.contacts[i];\r\n      const k2 = contact.effMass;\r\n\r\n      if (contact.penDepth <= 0) return;\r\n\r\n      contact.relVelocity = sum(\r\n        body2.velocity,\r\n        cross(body2.angularV, contact.rb)\r\n      );\r\n      contact.relVelocity = diff(contact.relVelocity, body1.velocity);\r\n      contact.relVelocity = diff(\r\n        contact.relVelocity,\r\n        cross(body1.angularV, contact.ra)\r\n      );\r\n      const Vc = dot(contact.relVelocity, contact.n);\r\n      const restitution = Math.max(Vc - tol2, 0) * 0.1;\r\n      let b = (Math.max(0, contact.penDepth - tol) / deltaTime) * 0.25;\r\n\r\n      let lambda = -Vc / contact.effMass;\r\n      let oldAcc = contact.accI;\r\n      contact.accI += lambda;\r\n      if (contact.accI < 0) contact.accI = 0;\r\n      lambda = contact.accI - oldAcc;\r\n\r\n      body1.applyImpulse(scale(contact.n, -lambda), contact.ra);\r\n      body2.applyImpulse(scale(contact.n, lambda), contact.rb);\r\n      frictionSolver(contact, lambda, body1, body2);\r\n    }\r\n  }\r\n}\r\n\r\nconst solveConstraint = (constraint, deltaTime) => {\r\n  const ra = constraint.body1.collider.localToGlobal(constraint.ra);\r\n  const rb = constraint.body2.collider.localToGlobal(constraint.rb);\r\n  const n = constraint.n;\r\n\r\n  if (constraint.dist < 0.01) return;\r\n  const normal = scale(constraint.n, 1 / constraint.dist);\r\n  let v1 = sum(\r\n    constraint.body1.velocity,\r\n    cross(constraint.body1.angularV, constraint.ra)\r\n  );\r\n  let v2 = sum(\r\n    constraint.body2.velocity,\r\n    cross(constraint.body2.angularV, constraint.rb)\r\n  );\r\n  let relVelocity = diff(v2, v1);\r\n\r\n  const Vc = dot(relVelocity, normal);\r\n  let b = (constraint.dist / deltaTime) * 0.2;\r\n  const softness = 2;\r\n  let lambda = -Vc / constraint.effMass;\r\n\r\n  constraint.body1.applyImpulse(scale(normal, -lambda), constraint.ra);\r\n  constraint.body2.applyImpulse(scale(normal, lambda), constraint.rb);\r\n};\r\n\r\nconst solvePosition = (constraint, deltaTime) => {\r\n  if (constraint.dist < 0.01) return;\r\n  const normal = scale(constraint.n, 1 / constraint.dist);\r\n  let v1 = sum(\r\n    constraint.body1.pseudoVelocity,\r\n    cross(constraint.body1.pseudoAngularV, constraint.ra)\r\n  );\r\n  let v2 = sum(\r\n    constraint.body2.pseudoVelocity,\r\n    cross(constraint.body2.pseudoAngularV, constraint.rb)\r\n  );\r\n  let relVelocity = diff(\r\n    constraint.body2.pseudoVelocity,\r\n    constraint.body1.pseudoVelocity\r\n  );\r\n\r\n  const Vc = dot(relVelocity, normal);\r\n\r\n  let b = Math.max(0, constraint.dist / deltaTime - 0.01);\r\n  const softness = 2;\r\n  let lambda =\r\n    (b - Vc) / (constraint.body1.inverseMass + constraint.body2.inverseMass);\r\n\r\n  if (Math.abs(lambda) < 0.1) return;\r\n\r\n  constraint.body1.applyPseudoImpulse(scale(normal, -lambda), [0, 0, 0]);\r\n  constraint.body2.applyPseudoImpulse(scale(normal, lambda), [0, 0, 0]);\r\n};\r\n\r\nconst solveContactPositionErr = (contact, deltaTime, n) => {\r\n  if (contact.penDepth < 0.01) return;\r\n\r\n  let v1 = sum(\r\n    contact.body1.pseudoVelocity,\r\n    cross(contact.body1.pseudoAngularV, contact.ra)\r\n  );\r\n  let v2 = sum(\r\n    contact.body2.pseudoVelocity,\r\n    cross(contact.body2.pseudoAngularV, contact.rb)\r\n  );\r\n  let relVelocity = diff(v2, v1);\r\n\r\n  const Vc = dot(relVelocity, contact.n);\r\n  //if(Vc < 0)return\r\n\r\n  let b = contact.penDepth / deltaTime / n;\r\n  //if(Vc >= b) return\r\n  let lambda =\r\n    (b - Vc) / (contact.body1.inverseMass + contact.body2.inverseMass);\r\n\r\n  contact.penDepth = 0;\r\n\r\n  //if(Math.abs(lambda) < 0.1)return\r\n\r\n  contact.body1.applyPseudoImpulse(scale(contact.n, -lambda), [0, 0, 0]);\r\n  contact.body2.applyPseudoImpulse(scale(contact.n, lambda), [0, 0, 0]);\r\n};\r\nexport { solveCollision, solvePosition, solveContactPositionErr };\r\n","import { vector, m3 } from \"math\";\r\n\r\nconst { dot, cross, normalize, diff, scale, norm, sum } = vector;\r\n\r\nclass Constraint {\r\n  constructor(body1, body2) {\r\n    this.bias = null;\r\n    this.n = null;\r\n    this.J = null;\r\n    this.invMass1 = null;\r\n    this.JM = null;\r\n    this.body1 = body1;\r\n    this.body2 = body2;\r\n    this.ra = null;\r\n    this.rb = null;\r\n  }\r\n  updateEq() {}\r\n  applyResolvingImpulse(lambda) {}\r\n}\r\nconst clamp = (v, min, max) => {\r\n  if (v > min) {\r\n    if (v < max) return v;\r\n    else return max;\r\n  }\r\n  return min;\r\n};\r\n\r\nconst frictionSolver = (contact, lambda, body1, body2) => {\r\n  contact.relVelocity = sum(body2.velocity, cross(body2.angularV, contact.rb));\r\n  contact.relVelocity = diff(contact.relVelocity, body1.velocity);\r\n  contact.relVelocity = diff(\r\n    contact.relVelocity,\r\n    cross(body1.angularV, contact.ra)\r\n  );\r\n\r\n  const mu = (body1.friction + body1.friction);\r\n  let fImpulse1 = -dot(contact.relVelocity, contact.fDir1) / contact.fEffMass1;\r\n  fImpulse1 = clamp(fImpulse1, -lambda * mu, lambda * mu);\r\n\r\n  let fImpulse2 = -dot(contact.relVelocity, contact.fDir2) / contact.fEffMass2;\r\n  fImpulse2 = clamp(fImpulse2, -lambda * mu, lambda * mu);\r\n\r\n  contact.accFI1 += fImpulse1;\r\n  contact.accFI2 += fImpulse2;\r\n\r\n  let fVec = sum(\r\n    scale(contact.fDir1, fImpulse1),\r\n    scale(contact.fDir2, fImpulse2)\r\n  );\r\n\r\n  body1.applyImpulse(scale(fVec, -1), contact.ra);\r\n  body2.applyImpulse(fVec, contact.rb);\r\n};\r\nclass Contact extends Constraint {\r\n  constructor(raLocal, rbLocal, n, body1, body2) {\r\n    super(body1, body2);\r\n    this.ra = null;\r\n    this.rb = null;\r\n    this.PA = null;\r\n    this.PB = null;\r\n    this.n = n;\r\n    this.penDepth = null;\r\n    this.initialVelProj = null;\r\n    this.effMass = null;\r\n    this.raLocal = raLocal;\r\n    this.rbLocal = rbLocal;\r\n    this.J = null;\r\n    this.accI = 0;\r\n    this.accFI1 = 0;\r\n    this.accFI2 = 0;\r\n    try {\r\n      if (dot(this.n, [1, 0, 0]) < 0.5) {\r\n        this.fDir1 = cross(this.n, [1, 0, 0]);\r\n      } else {\r\n        this.fDir1 = cross(this.n, [0, 0, 1]);\r\n      }\r\n      this.fDir2 = normalize(cross(this.fDir1, this.n));\r\n      this.fDir1 = normalize(this.fDir1);\r\n    } catch (err) {\r\n      console.log(this.n);\r\n      throw new Error();\r\n    }\r\n  }\r\n  _J() {\r\n    return [\r\n      scale(this.n, -1),\r\n      cross(this.n, this.ra),\r\n      this.n,\r\n      cross(this.rb, this.n),\r\n    ];\r\n  }\r\n  updateContactData() {\r\n    const col1 = this.body1.collider;\r\n    const col2 = this.body2.collider;\r\n    const PA = sum(col1.pos, m3.transformPoint(col1.Rmatrix, this.raLocal));\r\n    const PB = sum(col2.pos, m3.transformPoint(col2.Rmatrix, this.rbLocal));\r\n\r\n    this.ra = diff(PA, col1.pos);\r\n    this.rb = diff(PB, col2.pos);\r\n    this.penDepth = -dot(diff(PB, PA), this.n);\r\n  }\r\n  updateEq() {\r\n    this.updateContactData();\r\n    this.J = [\r\n      scale(this.n, -1),\r\n      cross(this.n, this.ra),\r\n      this.n,\r\n      cross(this.rb, this.n),\r\n    ];\r\n    const I1 = this.body1.getItensor();\r\n    const I2 = this.body2.getItensor();\r\n    const M1 = this.body1.inverseMass;\r\n    const M2 = this.body2.inverseMass;\r\n    this.JM = [\r\n      scale(this.J[0], M1),\r\n      m3.transformPoint(I1, this.J[1]),\r\n      scale(this.J[2], M2),\r\n      m3.transformPoint(I2, this.J[3]),\r\n    ];\r\n    this.effMass =\r\n      M1 + dot(this.JM[0], this.J[1]) + M2 + dot(this.JM[3], this.J[3]);\r\n    const tJ1 = [\r\n      this.fDir1,\r\n      cross(this.fDir1, this.ra),\r\n      scale(this.fDir1, -1),\r\n      cross(this.rb, this.fDir1),\r\n    ];\r\n    this.fEffMass1 =\r\n      this.body1.inverseMass +\r\n      m3.dot(m3.transformPoint(this.body1.inverseInertia, tJ1[1]), tJ1[1]) +\r\n      this.body2.inverseMass +\r\n      m3.dot(m3.transformPoint(this.body2.inverseInertia, tJ1[3]), tJ1[3]);\r\n    const tJ2 = [\r\n      scale(this.fDir2, -1),\r\n      cross(this.fDir2, this.ra),\r\n      this.fDir2,\r\n      cross(this.fDir2, this.rb),\r\n    ];\r\n    this.fEffMass2 =\r\n      this.body1.inverseMass +\r\n      m3.dot(m3.transformPoint(this.body1.inverseInertia, tJ2[1]), tJ2[1]) +\r\n      this.body2.inverseMass +\r\n      m3.dot(m3.transformPoint(this.body2.inverseInertia, tJ2[3]), tJ2[3]);\r\n    this.bias = this.penDepth;\r\n  }\r\n  applyResolvingImpulse(lambda) {\r\n    if (lambda < 0) return;\r\n\r\n    this.body1.applyImpulse(scale(this.J[0], lambda), this.ra);\r\n    this.body2.applyImpulse(scale(this.J[2], lambda), this.rb);\r\n    frictionSolver(this, lambda, this.body1, this.body2)\r\n  }\r\n  applyResolvingPseudoImpulse(lambda) {\r\n    if (lambda < 0) return;\r\n    lambda = Math.min(10, lambda);\r\n    this.body1.applyPseudoImpulse(scale(this.J[0], lambda), this.ra);\r\n    this.body2.applyPseudoImpulse(scale(this.J[2], lambda), this.rb);\r\n  }\r\n  generateFrictionConstraints() {\r\n    let fDir1, fDir2;\r\n\r\n    if (dot(this.n, [1, 0, 0]) < 0.5) {\r\n      fDir1 = cross(this.n, [1, 0, 0]);\r\n    } else {\r\n      fDir1 = cross(this.n, [0, 0, 1]);\r\n    }\r\n    fDir2 = normalize(cross(fDir1, this.n));\r\n    fDir1 = normalize(fDir1);\r\n\r\n    return [\r\n      new FrictionConstraint(fDir1, this.ra, this.rb, this.body1, this.body2),\r\n      new FrictionConstraint(fDir2, this.ra, this.rb, this.body1, this.body2),\r\n    ];\r\n  }\r\n}\r\nclass FrictionConstraint extends Constraint {\r\n  constructor(fDir, ra, rb, body1, body2) {\r\n    super(body1, body2);\r\n    this.fDir = fDir;\r\n    this.ra = ra;\r\n    this.rb = rb;\r\n  }\r\n  updateEq() {\r\n    this.J = [\r\n      this.fDir,\r\n      cross(this.fDir, this.ra),\r\n      scale(this.fDir, -1),\r\n      cross(this.rb, this.fDir),\r\n    ];\r\n    const I1 = this.body1.inverseInertia;\r\n    const I2 = this.body2.inverseInertia;\r\n    const M1 = this.body1.inverseMass;\r\n    const M2 = this.body2.inverseMass;\r\n    this.JM = [\r\n      scale(this.J[0], M1),\r\n      m3.transformPoint(I1, this.J[1]),\r\n      scale(this.J[2], M2),\r\n      m3.transformPoint(I2, this.J[3]),\r\n    ];\r\n    this.effMass =\r\n      M1 + dot(this.JM[0], this.J[1]) + M2 + dot(this.JM[3], this.J[3]);\r\n  }\r\n}\r\nclass Joint extends Constraint {\r\n  constructor(localRa, localRb, body1, body2) {\r\n    super(body1, body2);\r\n    this.localRa = localRa;\r\n    this.localRb = localRb;\r\n    this.PA = this.body1.collider.localToGlobal(this.localRa);\r\n    this.PB = this.body2.collider.localToGlobal(this.localRb);\r\n  }\r\n  updateEq() {\r\n    this.PA = this.body1.collider.localToGlobal(this.localRa);\r\n    this.PB = this.body2.collider.localToGlobal(this.localRb);\r\n    this.n = diff(this.PA, this.PB);\r\n    this.ra = diff(this.PA, this.body1.collider.pos);\r\n    this.rb = diff(this.PB, this.body2.collider.pos);\r\n    this.dist = norm(this.n);\r\n    this.J = [\r\n      scale(this.n, 1 / this.dist),\r\n      scale(cross(this.n, this.ra), 1 / this.dist),\r\n      scale(this.n, -1 / this.dist),\r\n      scale(cross(this.rb, this.n), 1 / this.dist),\r\n    ];\r\n    const I1 = this.body1.inverseInertia;\r\n    const I2 = this.body2.inverseInertia;\r\n    const M1 = this.body1.inverseMass;\r\n    const M2 = this.body2.inverseMass;\r\n    this.effMass =\r\n      M1 +\r\n      dot(m3.transformPoint(I1, this.J[1]), this.J[1]) +\r\n      M2 +\r\n      dot(m3.transformPoint(I2, this.J[3]), this.J[3]);\r\n  }\r\n}\r\nexport { Contact, Constraint, Joint };\r\n","class EventEmitter {\r\n  constructor() {\r\n    this.events = {};\r\n  }\r\n  on(eventName, fn) {\r\n    if (!this.events[eventName]) {\r\n      this.events[eventName] = [];\r\n    }\r\n    this.events[eventName].push(fn);\r\n    return () => {\r\n      this.events[eventName] = this.events[eventName].filter(\r\n        (eventFn) => fn !== eventFn\r\n      );\r\n    };\r\n  }\r\n  emit(eventName, data) {\r\n    if (this.events[eventName]) {\r\n      this.events[eventName].forEach((fn) => {\r\n        fn.call(null, data);\r\n      });\r\n    }\r\n  }\r\n}\r\nexport { EventEmitter };\r\n","import { vector, m3, m4 } from \"math\";\r\nimport { Contact } from \"./contact\";\r\nconst { dot, cross, normalize, sum, diff, len, scale, isNull, norm } = vector;\r\n\r\nconst GJK_MAX_ITERATIONS_NUM = 64;\r\n\r\nconst findClosestFace = (collider, normal) => {\r\n  const normals = collider.getNormalsGlobal();\r\n  let minDot = dot(normal, normals[0]);\r\n  let index = 0;\r\n  for (let i = 1, n = normals.length; i < n; i++) {\r\n    const _dot = dot(normals[i], normal);\r\n    if (_dot < minDot) {\r\n      minDot = _dot;\r\n      index = i;\r\n    }\r\n  }\r\n  const faceIndices = collider.indices[index];\r\n  const m = collider.getM4();\r\n  return faceIndices.map((i) => m4.transformPoint(m, collider.points[i]));\r\n};\r\n\r\nfunction update_simplex3(a, b, c, d, search_dir, simp_dim) {\r\n  const n = cross(diff(this.b, this.a), diff(this.c, this.a));\r\n  const AO = scale(this.a, -1);\r\n\r\n  this.simp_dim = 2;\r\n  if (dot(cross(diff(this.b, this.a), n), AO) > 0) {\r\n    this.c = this.a;\r\n    this.search_dir = cross(\r\n      cross(diff(this.b, this.a), AO),\r\n      diff(this.b, this.a)\r\n    );\r\n    return;\r\n  }\r\n  if (dot(cross(n, diff(this.c, this.a)), AO) > 0) {\r\n    this.b = this.a;\r\n    this.search_dir = cross(\r\n      cross(diff(this.c, this.a), AO),\r\n      diff(this.c, this.a)\r\n    );\r\n    return;\r\n  }\r\n  this.simp_dim = 3;\r\n  if (dot(n, AO) > 0) {\r\n    this.d = this.c;\r\n    this.c = this.b;\r\n    this.b = this.a;\r\n    this.search_dir = n;\r\n    return;\r\n  }\r\n  this.d = this.b;\r\n  this.b = this.a;\r\n  this.search_dir = scale(n, -1);\r\n  return;\r\n}\r\nfunction update_simplex4(a, b, c, d, search_dir, simp_dim) {\r\n  const ABC = cross(diff(this.b, this.a), diff(this.c, this.a));\r\n  const ACD = cross(diff(this.c, this.a), diff(this.d, this.a));\r\n  const ADB = cross(diff(this.d, this.a), diff(this.b, this.a));\r\n  const AO = scale(this.a, -1);\r\n  this.simp_dim = 3;\r\n\r\n  if (dot(ABC, AO) > 0) {\r\n    this.d = this.c;\r\n    this.c = this.b;\r\n    this.b = this.a;\r\n    this.search_dir = ABC;\r\n    return false;\r\n  }\r\n\r\n  if (dot(ACD, AO) > 0) {\r\n    this.b = this.a;\r\n    this.search_dir = ACD;\r\n    return false;\r\n  }\r\n\r\n  if (dot(ADB, AO) > 0) {\r\n    this.c = this.d;\r\n    this.d = this.b;\r\n    this.b = this.a;\r\n    this.search_dir = ADB;\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\nfunction gjk(body1, body2) {\r\n  const coll1 = body1.collider;\r\n  const coll2 = body2.collider;\r\n  this.a = [0, 0, 0];\r\n  this.b = [0, 0, 0];\r\n  this.c = [0, 0, 0];\r\n  this.d = [0, 0, 0];\r\n  this.search_dir = [0, 0, 0];\r\n  this.simp_dim = 0;\r\n\r\n  this.originsMap = new Map();\r\n\r\n  let mtv = [0, 0, 0];\r\n\r\n  this.search_dir = diff(coll1.pos, coll2.pos);\r\n  const c_origin1 = coll1.support(scale(this.search_dir, -1));\r\n  const c_origin2 = coll2.support(this.search_dir);\r\n  this.c = diff(c_origin2, c_origin1);\r\n\r\n  this.originsMap.set(this.c, [c_origin1, c_origin2]);\r\n\r\n  this.search_dir = scale(this.c, -1);\r\n\r\n  const b_origin1 = coll1.support(scale(this.search_dir, -1));\r\n  const b_origin2 = coll2.support(this.search_dir);\r\n  this.b = diff(b_origin2, b_origin1);\r\n\r\n  this.originsMap.set(this.b, [b_origin1, b_origin2]);\r\n\r\n  if (dot(this.b, this.search_dir) < 0) {\r\n    return false;\r\n  }\r\n\r\n  this.search_dir = cross(\r\n    cross(diff(this.c, this.b), scale(this.b, -1)),\r\n    diff(this.c, this.b)\r\n  );\r\n\r\n  if (isNull(this.search_dir)) {\r\n    this.search_dir = cross(diff(this.c, this.b), [1, 0, 0]);\r\n\r\n    if (isNull(this.search_dir)) {\r\n      this.search_dir = cross(diff(this.c, this.b), [0, 0, -1]);\r\n    }\r\n  }\r\n\r\n  this.simp_dim = 2;\r\n  for (let i = 0; i < GJK_MAX_ITERATIONS_NUM; ++i) {\r\n    const a_origin1 = coll1.support(scale(this.search_dir, -1));\r\n    const a_origin2 = coll2.support(this.search_dir);\r\n    this.a = diff(a_origin2, a_origin1);\r\n\r\n    this.originsMap.set(this.a, [a_origin1, a_origin2]);\r\n    if (dot(this.a, this.search_dir) < 0) return false;\r\n\r\n    this.simp_dim++;\r\n    if (this.simp_dim === 3) {\r\n      update_simplex3.apply(this);\r\n    } else if (update_simplex4.apply(this)) {\r\n      return EPA(this.a, this.b, this.c, this.d, this.originsMap, body1, body2);\r\n    }\r\n  }\r\n}\r\n\r\nconst baricentric = (face, point) => {\r\n  let a11 = face[0][0];\r\n  let a12 = face[1][0];\r\n  let a13 = face[2][0];\r\n  let b1 = point[0];\r\n  let a21 = face[0][1];\r\n  let a22 = face[1][1];\r\n  let a23 = face[2][1];\r\n  let b2 = point[1];\r\n  let a31 = face[0][2];\r\n  let a32 = face[1][2];\r\n  let a33 = face[2][2];\r\n  let b3 = point[2];\r\n\r\n  const d =\r\n    a11 * a22 * a33 +\r\n    a21 * a32 * a13 +\r\n    a12 * a23 * a31 -\r\n    a13 * a22 * a31 -\r\n    a21 * a12 * a33 -\r\n    a32 * a23 * a11;\r\n\r\n  const d1 =\r\n    b1 * a22 * a33 +\r\n    b2 * a32 * a13 +\r\n    a12 * a23 * b3 -\r\n    a13 * a22 * b3 -\r\n    b2 * a12 * a33 -\r\n    a32 * a23 * b1;\r\n\r\n  const d2 =\r\n    a11 * b2 * a33 +\r\n    a21 * b3 * a13 +\r\n    b1 * a23 * a31 -\r\n    a13 * b2 * a31 -\r\n    a11 * b3 * a23 -\r\n    a21 * b1 * a33;\r\n\r\n  const d3 =\r\n    a11 * a22 * b3 +\r\n    a21 * a32 * b1 +\r\n    a12 * b2 * a31 -\r\n    b1 * a22 * a31 -\r\n    a21 * a12 * b3 -\r\n    b2 * a32 * a11;\r\n\r\n  return [d1 / d, d2 / d, d3 / d];\r\n};\r\nconst originToFaceProj = (face) => {\r\n  const normal = face[3];\r\n  const point = face[0];\r\n  const c = -normal[0] * point[0] - normal[1] * point[1] - normal[2] * point[2];\r\n  const t =\r\n    -c /\r\n    (normal[0] * normal[0] + normal[1] * normal[1] + normal[2] * normal[2]);\r\n  return [t * normal[0], t * normal[1], t * normal[2]];\r\n};\r\n\r\nconst TOLERANCE = 0.001;\r\nconst MAX_NUM_FACES = 64;\r\nconst MAX_NUM_LOOSE_EDGES = 32;\r\nconst EPA_MAX_NUM_ITER = 64;\r\nconst EPA = (a, b, c, d, originsMap, body1, body2) => {\r\n  const coll1 = body1.collider;\r\n  const coll2 = body2.collider;\r\n  const faces = [];\r\n  for (let i = 0; i < 4; i++) {\r\n    faces[i] = [];\r\n  }\r\n\r\n  faces[0][0] = a;\r\n  faces[0][1] = b;\r\n  faces[0][2] = c;\r\n  faces[0][3] = normalize(cross(diff(b, a), diff(c, a)));\r\n  faces[1][0] = a;\r\n  faces[1][1] = c;\r\n  faces[1][2] = d;\r\n  faces[1][3] = normalize(cross(diff(c, a), diff(d, a)));\r\n  faces[2][0] = a;\r\n  faces[2][1] = d;\r\n  faces[2][2] = b;\r\n  faces[2][3] = normalize(cross(diff(d, a), diff(b, a)));\r\n  faces[3][0] = b;\r\n  faces[3][1] = d;\r\n  faces[3][2] = c;\r\n  faces[3][3] = normalize(cross(diff(d, b), diff(c, b)));\r\n\r\n  let num_faces = 4;\r\n  let closest_face = null;\r\n  let search_dir;\r\n\r\n  let p;\r\n  for (let iteration = 0; iteration < EPA_MAX_NUM_ITER; ++iteration) {\r\n    let min_dist = dot(faces[0][0], faces[0][3]);\r\n\r\n    closest_face = 0;\r\n    for (let i = 0; i < num_faces; ++i) {\r\n      let dist = dot(faces[i][0], faces[i][3]);\r\n      if (dist < min_dist) {\r\n        min_dist = dist;\r\n        closest_face = i;\r\n      }\r\n    }\r\n    search_dir = faces[closest_face][3];\r\n\r\n    const p_origin1 = coll1.support(scale(search_dir, -1));\r\n    const p_origin2 = coll2.support(search_dir);\r\n    p = diff(p_origin2, p_origin1);\r\n    originsMap.set(p, [p_origin1, p_origin2]);\r\n\r\n    if (dot(p, search_dir) - min_dist < 0.00001) {\r\n      const face = faces[closest_face];\r\n\r\n      const point = originToFaceProj(face);\r\n\r\n      const [Aa, Ba] = originsMap.get(face[0]);\r\n      //const Aa = face[0].oa\r\n      //const Ba = face[0].ob\r\n      const [Ab, Bb] = originsMap.get(face[1]);\r\n      //const Ab = face[1].oa\r\n      //const Bb = face[1].ob\r\n      const [Ac, Bc] = originsMap.get(face[2]);\r\n      //const Ac = face[2].oa\r\n      //const Bc = face[2].ob\r\n\r\n      const result = baricentric(face, point);\r\n\r\n      if (isNaN(result[0] + result[1] + result[2])) {\r\n        console.log(\"no conv\");\r\n        return false;\r\n      }\r\n\r\n      let PA = sum(\r\n        sum(scale(Aa, result[0]), scale(Ab, result[1])),\r\n        scale(Ac, result[2])\r\n      );\r\n      //Aa.multiply(result[0]).add(Ab.multiply(result[1])).add(Ac.multiply(result[2]))\r\n      let PB = sum(\r\n        sum(scale(Ba, result[0]), scale(Bb, result[1])),\r\n        scale(Bc, result[2])\r\n      );\r\n      //Ba.multiply(result[0]).add(Bb.multiply(result[1])).add(Bc.multiply(result[2]))\r\n\r\n      //const ra = PA.substract(coll1.pos)\r\n\r\n      const rb = diff(PB, coll2.pos);\r\n      const ra = diff(PA, coll1.pos);\r\n      const raLocal = m3.transformPoint(coll1.RmatrixInverse, ra);\r\n      const rbLocal = m3.transformPoint(coll2.RmatrixInverse, rb);\r\n      const n = normalize(scale(face[3], -dot(p, search_dir)));\r\n      if (norm(n) < 0.01) return false;\r\n      const penDepth = -dot(diff(PB, PA), n);\r\n      const contactFace1 = findClosestFace(coll1, n);\r\n      const contactFace2 = findClosestFace(coll2, n);\r\n      const contact = new Contact(raLocal, rbLocal, n, body1, body2);\r\n      contact.PA = PA;\r\n      contact.PB = PB;\r\n      contact.rb = rb;\r\n      contact.ra = ra;\r\n      contact.penDepth = penDepth;\r\n      contact.contactFace1 = contactFace1;\r\n      contact.contactFace2 = contactFace2;\r\n      return contact;\r\n    }\r\n\r\n    const loose_edges = [];\r\n    let num_loose_edges = 0;\r\n    for (let i = 0; i < num_faces; ++i) {\r\n      if (dot(faces[i][3], diff(p, faces[i][0])) > 0) {\r\n        for (let j = 0; j < 3; j++) {\r\n          let current_edge = [faces[i][j], faces[i][(j + 1) % 3]];\r\n          let found_edge = false;\r\n          for (let k = 0; k < num_loose_edges; k++) {\r\n            if (\r\n              loose_edges[k][1] === current_edge[0] &&\r\n              loose_edges[k][0] === current_edge[1]\r\n            ) {\r\n              loose_edges[k][0] = loose_edges[num_loose_edges - 1][0];\r\n              loose_edges[k][1] = loose_edges[num_loose_edges - 1][1];\r\n              num_loose_edges--;\r\n              found_edge = true;\r\n              k = num_loose_edges;\r\n            }\r\n          }\r\n          if (!found_edge) {\r\n            if (num_loose_edges >= MAX_NUM_LOOSE_EDGES) break;\r\n\r\n            loose_edges[num_loose_edges] = [];\r\n            loose_edges[num_loose_edges][0] = current_edge[0];\r\n            loose_edges[num_loose_edges][1] = current_edge[1];\r\n            num_loose_edges++;\r\n          }\r\n        }\r\n        faces[i][0] = faces[num_faces - 1][0];\r\n        faces[i][1] = faces[num_faces - 1][1];\r\n        faces[i][2] = faces[num_faces - 1][2];\r\n        faces[i][3] = faces[num_faces - 1][3];\r\n        num_faces--;\r\n        i--;\r\n      }\r\n    }\r\n    for (let i = 0; i < num_loose_edges; i++) {\r\n      if (num_faces >= MAX_NUM_FACES) break;\r\n      faces[num_faces] = [];\r\n      faces[num_faces][0] = loose_edges[i][0];\r\n      faces[num_faces][1] = loose_edges[i][1];\r\n      faces[num_faces][2] = p;\r\n\r\n      faces[num_faces][3] = normalize(\r\n        cross(\r\n          diff(loose_edges[i][0], loose_edges[i][1]),\r\n          diff(loose_edges[i][0], p)\r\n        )\r\n      );\r\n\r\n      if (dot(faces[num_faces][0], faces[num_faces][3]) + 0.01 < 0) {\r\n        temp = faces[num_faces][0];\r\n        faces[num_faces][0] = faces[num_faces][1];\r\n        faces[num_faces][1] = temp;\r\n        faces[num_faces][3] = scale(faces[num_faces][3], -1);\r\n      }\r\n      num_faces++;\r\n    }\r\n  }\r\n  console.log(\"no conv\");\r\n  return false;\r\n};\r\nexport default gjk.bind({});\r\n","import { vector as vec } from \"math\";\r\n\r\nexport default class Island {\r\n  constructor(...constraints) {\r\n    this.constraints = [...constraints];\r\n    this.JMJ = null;\r\n    this.JV = null;\r\n    this.JpV = null;\r\n    this.JMJp = null;\r\n  }\r\n  addConstraint(...args) {\r\n    this.constraints.push(...args);\r\n  }\r\n  generatePseudoVelVector() {}\r\n  generateSystem(deltaTime) {\r\n    const n = this.constraints.length;\r\n    //A = JMJ*, JMJ*x = JV + b\r\n    this.JMJp = new Array(n * n);\r\n    this.JMJ = new Array(n * n);\r\n    this.JV = new Array(n);\r\n    this.JpV = new Array(n);\r\n    for (let i = 0; i < n; i++) {\r\n      const constraint = this.constraints[i];\r\n      const { body1, body2, JM, J } = constraint;\r\n      const k = i * n;\r\n      for (let j = 0; j < n; j++) {\r\n        if (k === j) {\r\n          this.JMJ[k + j] = () => constraint.effMass;\r\n          this.JMJp[k + j] = () =>\r\n            constraint.body1.inverseMass + constraint.body2.inverseMass;\r\n          continue;\r\n        }\r\n\r\n        const _constraint = this.constraints[j];\r\n\r\n        const _body1 = _constraint.body1;\r\n        const _body2 = _constraint.body2;\r\n        const _J = _constraint.J;\r\n        const fp1 = body1 === _body1 ? () => vec.dot(JM[0], _J[0]) : () => 0;\r\n        const fp2 = body2 === _body2 ? () => vec.dot(JM[2], _J[2]) : () => 0;\r\n        const fp3 = body1 === _body2 ? () => vec.dot(JM[0], _J[2]) : () => 0;\r\n        const fp4 = body2 === _body1 ? () => vec.dot(JM[2], _J[0]) : () => 0;\r\n        const f1 =\r\n          body1 === _body1\r\n            ? () => vec.dot(JM[0], _J[0]) + vec.dot(JM[1], _J[1])\r\n            : () => 0;\r\n        const f2 =\r\n          body2 === _body2\r\n            ? () => vec.dot(JM[2], _J[2]) + vec.dot(JM[3], _J[3])\r\n            : () => 0;\r\n        const f3 =\r\n          body1 === _body2\r\n            ? () => vec.dot(JM[0], _J[2]) + vec.dot(JM[1], _J[3])\r\n            : () => 0;\r\n        const f4 =\r\n          body2 === _body1\r\n            ? () => vec.dot(JM[2], _J[0]) + vec.dot(JM[3], _J[1])\r\n            : () => 0;\r\n        this.JMJ[k + j] = () => f1() + f2() + f3() + f4();\r\n        this.JMJp[k + j] = () => fp1() + fp2() + fp3() + fp4();\r\n      }\r\n      let b = Math.max(0, constraint.bias - 0.01) / deltaTime;\r\n      const rv =\r\n        vec.dot(J[0], body1.velocity) +\r\n        vec.dot(J[1], body1.angularV) +\r\n        vec.dot(J[2], body2.velocity) +\r\n        vec.dot(J[3], body2.angularV);\r\n      this.JV[i] = () => -rv + b * 0.015;\r\n\r\n      /*this.JpV[i] = () => -vec.dot(J[0], body1.pseudoVelocity) -\r\n                            vec.dot(J[1], body1.pseudoAngularV) -\r\n                            vec.dot(J[2], body2.pseudoVelocity) -\r\n                           vec.dot(J[3], body2.pseudoAngularV) - constraint.bias/deltaTime */\r\n      this.JpV[i] = () => b;\r\n    }\r\n  }\r\n  getJMJ() {\r\n    return this.JMJ.map((f) => f());\r\n  }\r\n  getJv() {\r\n    return this.JV.map((f) => f());\r\n  }\r\n  getJpV() {\r\n    return this.JpV.map((f) => f());\r\n  }\r\n  getJMJp() {\r\n    return this.JMJp.map((f) => f());\r\n  }\r\n  getUpdatedValues() {\r\n    return [\r\n      this.JMJ.map((f) => f()),\r\n      this.JV.map((f) => f()),\r\n      this.JpV.map((f) => f()),\r\n    ];\r\n  }\r\n  applyResolvingImpulses(lambda) {\r\n    for (let i = 0, n = this.constraints.length; i < n; i++) {\r\n      this.constraints[i].applyResolvingImpulse(lambda[i]);\r\n    }\r\n  }\r\n  applyResolvingPseudoImpulses(lambda) {\r\n    for (let i = 0, n = this.constraints.length; i < n; i++) {\r\n      this.constraints[i].applyResolvingPseudoImpulse(lambda[i]);\r\n    }\r\n  }\r\n}\r\n","import { m3, vector } from \"math\";\r\n\r\nconst { distanceFromLine, norm, findFurthestPoint, sum, diff, normSq, dot } =\r\n  vector;\r\n\r\nconst prec = 0.005;\r\nconst prec2 = 0.05;\r\nexport default class Manifold {\r\n  constructor(body1, body2) {\r\n    this.contacts = [];\r\n    this.body1 = body1;\r\n    this.body2 = body2;\r\n    this.warm = 0;\r\n  }\r\n  addContact(contact) {\r\n    let isFarEnough = true;\r\n    const contacts = this.contacts;\r\n\r\n    for (let i = 0, n = contacts.length; i < n; i++) {\r\n      const biasA = diff(contacts[i].PA, contact.PA);\r\n      const biasB = diff(contacts[i].PB, contact.PB);\r\n      if (norm(biasA) < prec2 && norm(biasB) < prec2) {\r\n        isFarEnough = false;\r\n        //contact.accI = contacts[i].accI\r\n        contacts[i] = contact;\r\n      }\r\n    }\r\n    if (isFarEnough) {\r\n      contacts.push(contact);\r\n    }\r\n  }\r\n  update() {\r\n    this.warm++;\r\n    let i, j, n;\r\n    const contacts = this.contacts;\r\n    const pos1 = this.body1.collider.pos;\r\n    const pos2 = this.body2.collider.pos;\r\n    for (i = 0, j = 0, n = contacts.length; i < n; i++) {\r\n      const contact = contacts[i];\r\n\r\n      const newPA = sum(\r\n        pos1,\r\n        m3.transformPoint(this.body1.collider.Rmatrix, contact.raLocal)\r\n      );\r\n      const newPB = sum(\r\n        pos2,\r\n        m3.transformPoint(this.body2.collider.Rmatrix, contact.rbLocal)\r\n      );\r\n      const raBias = diff(contact.PA, newPA);\r\n      const rbBias = diff(contact.PB, newPB);\r\n      const penDepth = -dot(diff(newPB, newPA), contact.n);\r\n\r\n      if (norm(raBias) < prec2 && norm(rbBias) < prec2 && penDepth > 0) {\r\n        //contact.raLocal = m3.transformPoint(this.body1.collider.RmatrixInverse,contact.ra)\r\n        //contact.rbLocal = m3.transformPoint(this.body2.collider.RmatrixInverse,contact.rb)\r\n\r\n        contacts[j] = contacts[i];\r\n\r\n        j++;\r\n      }\r\n    }\r\n\r\n    while (j < contacts.length) {\r\n      contacts.pop();\r\n    }\r\n    if (contacts.length > 2) this.warm++;\r\n    if (contacts.length < 3) this.warm = 0;\r\n    if (contacts.length > 4) {\r\n      let deepest = null;\r\n      let maxDeep = 0;\r\n      for (i = 0, n = contacts.length; i < n; i++) {\r\n        if (normSq(contacts[i].n) >= maxDeep) {\r\n          maxDeep = normSq(contacts[i].n);\r\n          deepest = contacts[i];\r\n        }\r\n      }\r\n      let furthest = null;\r\n      let maxDistance = 0;\r\n      for (i = 0, n = contacts.length; i < n; i++) {\r\n        let dist = normSq(diff(contacts[i].PA, deepest.PA));\r\n        if (dist >= maxDistance) {\r\n          maxDistance = dist;\r\n          furthest = contacts[i];\r\n        }\r\n      }\r\n      let furthest2 = null;\r\n      maxDistance = 0;\r\n      for (i = 0, n = contacts.length; i < n; i++) {\r\n        let dist = distanceFromLine(furthest.PA, deepest.PA, contacts[i].PA);\r\n\r\n        if (dist >= maxDistance) {\r\n          maxDistance = dist;\r\n          furthest2 = contacts[i];\r\n        }\r\n      }\r\n\r\n      let furthest3 = null;\r\n      maxDistance = 0;\r\n\r\n      const oppositeTodiagonal = findFurthestPoint(\r\n        deepest.PA,\r\n        furthest.PA,\r\n        furthest2.PA\r\n      );\r\n\r\n      for (i = 0, n = contacts.length; i < n; i++) {\r\n        let dist = normSq(diff(oppositeTodiagonal, contacts[i].PA));\r\n\r\n        if (dist >= maxDistance) {\r\n          maxDistance = dist;\r\n          furthest3 = contacts[i];\r\n        }\r\n      }\r\n\r\n      contacts[0] = deepest;\r\n      contacts[1] = furthest;\r\n      contacts[2] = furthest2;\r\n      contacts[3] = furthest3;\r\n\r\n      while (contacts.length > 4) contacts.pop();\r\n    }\r\n  }\r\n}\r\n","import { EventEmitter } from \"./eventEmitter\";\r\nimport { m3, vector, AABB } from \"math\";\r\nconst { cross, scale, norm, sum, diff, chkV } = vector;\r\nconst prec = 0.01;\r\nconst stopTreshold = 0.001;\r\nclass Physics extends EventEmitter {\r\n  constructor(collider) {\r\n    super();\r\n    this.static = false;\r\n    this.collider = collider;\r\n    this.mass = 1;\r\n    this.inverseMass = 1 / this.mass;\r\n    this.velocity = [0, 0, 0];\r\n    this.pseudoVelocity = [0, 0, 0];\r\n    this.pseudoAngularV = [0, 0, 0];\r\n    this.acceleration = [0, 0, 0];\r\n    this.angularV = [0, 0, 0];\r\n    this.inverseInertia = collider.getInverseInertiaTensor(this.mass);\r\n    this.id = 1;\r\n    this.friction = 0.1;\r\n    this.BVlink;\r\n  }\r\n  integrate(dt) {\r\n    const { acceleration, velocity, translation } = this;\r\n\r\n    this.translate(scale(this.velocity, dt));\r\n    const rotation = scale(this.angularV, dt * 0.5);\r\n    if (norm(rotation) > stopTreshold) this.rotate(rotation);\r\n    let deltaSpeed = scale(this.acceleration, dt);\r\n    this.velocity = sum(this.velocity, deltaSpeed);\r\n  }\r\n  integratePseudoVelocities(dt) {\r\n    const translation = scale(this.pseudoVelocity, dt);\r\n\r\n    const rotation = scale(this.pseudoAngularV, dt * 0.5);\r\n    if (norm(translation) > stopTreshold) this.translate(translation);\r\n\r\n    if (norm(rotation) > stopTreshold) this.rotate(rotation);\r\n\r\n    this.pseudoVelocity = [0, 0, 0];\r\n    this.pseudoAngularV = [0, 0, 0];\r\n  }\r\n  addPseudoVelocity(v) {\r\n    this.pseudoVelocity = sum(this.pseudoVelocity, v);\r\n  }\r\n  addPseudoAngularV(v) {\r\n    this.pseudoAngularV = sum(this.pseudoAngularV, v);\r\n  }\r\n  integrateVelocities(dt) {\r\n    const translation = scale(this.velocity, dt);\r\n    if (norm(translation) > stopTreshold) this.translate(translation);\r\n    const rotation = scale(this.angularV, dt * 0.5);\r\n    if (norm(translation) > stopTreshold) this.rotate(rotation);\r\n  }\r\n  integrateForces(dt) {\r\n    let deltaSpeed = scale(this.acceleration, dt);\r\n    this.velocity = sum(this.velocity, deltaSpeed);\r\n  }\r\n  updateInverseInertia() {\r\n    this.inverseInertia = this.collider.getInverseInertiaTensor(this.mass);\r\n  }\r\n  getItensor() {\r\n    return this.collider.getInverseInertiaTensor(this.mass);\r\n  }\r\n  setMass(mass) {\r\n    this.mass = mass;\r\n    this.inverseMass = 1 / this.mass;\r\n  }\r\n  translate(translation) {\r\n    this.collider.translate(translation);\r\n\r\n    this.emit(\"update\");\r\n  }\r\n  rotate(rotation) {\r\n    this.collider.rotate(rotation);\r\n\r\n    this.emit(\"update\");\r\n  }\r\n  applyImpulse(impulse, point) {\r\n    this.velocity = sum(this.velocity, scale(impulse, this.inverseMass));\r\n    const angularImpulse = m3.transformPoint(\r\n      this.getItensor(),\r\n      cross(point, impulse)\r\n    );\r\n    this.angularV = sum(this.angularV, angularImpulse);\r\n  }\r\n  applyPseudoImpulse(impulse, point) {\r\n    this.pseudoVelocity = sum(\r\n      this.pseudoVelocity,\r\n      scale(impulse, this.inverseMass)\r\n    );\r\n    const angularImpulse = m3.transformPoint(\r\n      this.getItensor(),\r\n      cross(point, impulse)\r\n    );\r\n    this.pseudoAngularV = sum(this.pseudoAngularV, angularImpulse);\r\n  }\r\n  addVelocity(v) {\r\n    chkV(v);\r\n    if (this.static) return;\r\n    this.velocity = sum(this.velocity, v);\r\n  }\r\n  addAngularV(v) {\r\n    chkV(v);\r\n    if (this.static) return;\r\n    this.angularV = sum(this.angularV, v);\r\n  }\r\n  addAcceleration(v) {\r\n    this.acceleration = sum(this.acceleration, v);\r\n  }\r\n  getExpandedAABB() {\r\n    const aabb = this.collider.getAABB();\r\n    const velocity = this.velocity;\r\n    const tr = [prec, prec, prec];\r\n    aabb.min = diff(aabb.min, tr);\r\n    aabb.max = sum(aabb.max, tr);\r\n\r\n    /*if(velocity[0] > 10) aabb.max[0] += velocity[0]\r\n      if(velocity[1] > 10) aabb.max[1] += velocity[1]\r\n      if(velocity[2] > 10) aabb.max[2] += velocity[2]\r\n      if(velocity[0] < -10) aabb.min[0] += velocity[0]\r\n      if(velocity[1] < -10) aabb.min[1] += velocity[1]\r\n      if(velocity[2] < -10) aabb.min[2] += velocity[2]*/\r\n    return aabb;\r\n  }\r\n  getAABB() {\r\n    return this.collider.getAABB();\r\n  }\r\n}\r\n\r\nclass Player extends Physics {\r\n  constructor() {\r\n    super(...arguments);\r\n    this.friction = 10;\r\n  }\r\n  applyImpulse(impulse, point) {\r\n    this.velocity = sum(this.velocity, scale(impulse, this.inverseMass));\r\n  }\r\n  applyPseudoImpulse(impulse) {\r\n    this.pseudoVelocity = sum(\r\n      this.pseudoVelocity,\r\n      scale(impulse, this.inverseMass)\r\n    );\r\n  }\r\n}\r\nexport { Physics, Player };\r\n","import Tree from \"./tree\";\r\n\r\nimport {\r\n  solveCollision,\r\n  solveContactPositionErr,\r\n  warmStart,\r\n  solvePosition,\r\n} from \"./constraints\";\r\nimport gjk from \"./gjk\";\r\n\r\nimport Manifold from \"./manifold\";\r\nimport Island from \"./island\";\r\nimport { GaussSeidel } from \"./GSsolver\";\r\nconst prec = 0.3;\r\nconst pairHash = (x, y) =>\r\n  x === Math.max(x, y) ? x * x + x + y : y * y + x + y;\r\n\r\nexport default class Simulation {\r\n  constructor() {\r\n    this.objects = [];\r\n    this.bvh = new Tree();\r\n    this.collisions = [];\r\n    this.constrains = [];\r\n    this.collisionManifolds = new Map();\r\n    this.lastId = 0;\r\n  }\r\n  addObject(object) {\r\n    const aabb = object.getExpandedAABB();\r\n\r\n    const leaf = this.bvh.insertLeaf(aabb, object);\r\n    object.BVlink = leaf;\r\n    object.id = this.lastId;\r\n    this.lastId++;\r\n    object.on(\"update\", () => this.updateObjectAABB.call(this, object));\r\n\r\n    this.objects.push(object);\r\n  }\r\n\r\n  updateObjectAABB(object) {\r\n    const newAABB = object.getAABB();\r\n\r\n    this.bvh.removeLeaf(object.BVlink);\r\n    const leaf = this.bvh.insertLeaf(newAABB, object);\r\n    object.BVlink = leaf;\r\n  }\r\n  removeObject(object) {\r\n    this.bvh.removeLeaf(object.BVlink);\r\n    this.objects = this.objects.filter((el) => el === object);\r\n  }\r\n  updateCollisions() {\r\n    const manifolds = this.collisionManifolds.values();\r\n\r\n    for (let i = 0, n = this.objects.length; i < n; i++) {\r\n      const object = this.objects[i];\r\n      if (object.static) continue;\r\n      const cols = this.bvh.getCollisions(object.BVlink);\r\n      object.BVlink.isChecked = true;\r\n      if (cols.length != 0)\r\n        for (let j = 0, n = cols.length; j < n; j++) {\r\n          const hash = pairHash(object.id, cols[j].id);\r\n          let manifold = this.collisionManifolds.get(hash);\r\n          //if(manifold && manifold.contacts.length > 4) continue\r\n          const contact = gjk(object, cols[j]);\r\n\r\n          if (!contact) {\r\n            if (manifold) this.collisionManifolds.delete(hash);\r\n            continue;\r\n          }\r\n\r\n          if (!manifold) {\r\n            manifold = new Manifold(object, cols[j]);\r\n            manifold.contacts = [contact];\r\n\r\n            this.collisionManifolds.set(hash, manifold);\r\n          } else manifold.addContact(contact);\r\n        }\r\n    }\r\n\r\n    this.bvh.setUnchecked();\r\n  }\r\n  tick(deltaTime) {\r\n    this.updateCollisions();\r\n    let manifolds = this.collisionManifolds.values();\r\n    for (let manifold of manifolds) manifold.update();\r\n\r\n    manifolds = this.collisionManifolds.values();\r\n    const system = new Island();\r\n    for (let manifold of manifolds) {\r\n      const contacts = manifold.contacts;\r\n      for (let i = 0, n = contacts.length; i < n; i++) {\r\n        contacts[i].updateEq();\r\n      }\r\n      system.addConstraint(...contacts);\r\n    }\r\n   \r\n    system.generateSystem(deltaTime);\r\n\r\n    for (let i = 0, n = this.objects.length; i < n; i++) {\r\n      this.objects[i].integrateForces(deltaTime);\r\n    }\r\n\r\n    const [_JMJ, _JV, _JpV] = system.getUpdatedValues();\r\n    const lambda = GaussSeidel(_JMJ, _JV, system.constraints.length, 1e-7);\r\n    system.applyResolvingImpulses(lambda);\r\n\r\n    for (let i = 0, n = this.objects.length; i < n; i++) {\r\n      this.objects[i].integrateVelocities(deltaTime);\r\n    }\r\n\r\n    manifolds = this.collisionManifolds.values();\r\n    for(const manifold of manifolds){\r\n        const {contacts} = manifold\r\n        if(contacts.length > 3){\r\n            contacts.forEach(contact => contact.updateEq())\r\n            const _system = new Island(...contacts)\r\n            _system.generateSystem(deltaTime)\r\n            const JMJ = _system.getJMJ();\r\n            const JpV = _system.getJpV();\r\n            const pLambda = GaussSeidel(JMJ, JpV, _system.constraints.length, 1e-7);\r\n            _system.applyResolvingPseudoImpulses(pLambda, deltaTime)\r\n        }\r\n    }\r\n    \r\n    \r\n\r\n    for (let i = 0, n = this.objects.length; i < n; i++) {\r\n      this.objects[i].integratePseudoVelocities(deltaTime)\r\n    }\r\n    //for(let i = 0; i<4; i++)\r\n  }\r\n}\r\n","import { AABB } from \"math\";\r\nconst getBoundAabb = (aabb1, aabb2) => {\r\n  if (!aabb1 || !aabb2) {\r\n    return 0;\r\n  }\r\n  const x1 = aabb1.min[0] < aabb2.min[0] ? aabb1.min[0] : aabb2.min[0];\r\n  const x2 = aabb1.max[0] > aabb2.max[0] ? aabb1.max[0] : aabb2.max[0];\r\n  const y1 = aabb1.min[1] < aabb2.min[1] ? aabb1.min[1] : aabb2.min[1];\r\n  const y2 = aabb1.max[1] > aabb2.max[1] ? aabb1.max[1] : aabb2.max[1];\r\n  const z1 = aabb1.min[2] < aabb2.min[2] ? aabb1.min[2] : aabb2.min[2];\r\n  const z2 = aabb1.max[2] > aabb2.max[2] ? aabb1.max[2] : aabb2.max[2];\r\n  return new AABB([x1, y1, z1], [x2, y2, z2]);\r\n};\r\nconst isCollide = (aabb1, aabb2) => {\r\n  if (\r\n    aabb1.min[0] <= aabb2.max[0] &&\r\n    aabb1.max[0] >= aabb2.min[0] &&\r\n    aabb1.min[1] <= aabb2.max[1] &&\r\n    aabb1.max[1] >= aabb2.min[1] &&\r\n    aabb1.min[2] <= aabb2.max[2] &&\r\n    aabb1.max[2] >= aabb2.min[2]\r\n  ) {\r\n    return true;\r\n  }\r\n  return false;\r\n};\r\nconst getSize = (aabb) => {\r\n  const area =\r\n    Math.abs(aabb.max[0] - aabb.min[0]) *\r\n    Math.abs(aabb.max[1] - aabb.min[1]) *\r\n    Math.abs(aabb.max[2] - aabb.min[2]);\r\n  return area;\r\n};\r\nclass Node {\r\n  constructor(aabb, isLeaf, gameObject) {\r\n    this.aabb = aabb;\r\n    this.isLeaf = isLeaf;\r\n    this.parent = null;\r\n\r\n    this.gameObject = gameObject;\r\n    this.isChecked = false;\r\n  }\r\n}\r\nexport default class Tree {\r\n  constructor() {\r\n    this.root = null;\r\n    this.leafs = {};\r\n    this.unusedIndexes = [];\r\n  }\r\n  setUnchecked() {\r\n    const stack = [this.root];\r\n\r\n    while (stack.length != 0) {\r\n      const node = stack.pop();\r\n      if (node.isLeaf) {\r\n        node.isChecked = false;\r\n        continue;\r\n      }\r\n      if (node.child1) stack.push(node.child1);\r\n      if (node.child2) stack.push(node.child2);\r\n    }\r\n  }\r\n  getBestSibling(leaf) {\r\n    let potential = this.root;\r\n    while (!potential.isLeaf) {\r\n      const size = getSize(potential.aabb);\r\n      const combinedAABB = getBoundAabb(potential.aabb, leaf.aabb);\r\n      const combinedSize = getSize(combinedAABB);\r\n      let cost = combinedSize;\r\n      let inherCost = combinedSize - size;\r\n\r\n      let cost1;\r\n      if (potential.child1.isLeaf) {\r\n        cost1 = getSize(potential.child1.aabb) + inherCost;\r\n      } else {\r\n        cost1 =\r\n          getSize(getBoundAabb(leaf.aabb, potential.child1.aabb)) -\r\n          getSize(potential.child1.aabb) +\r\n          inherCost;\r\n      }\r\n\r\n      let cost2;\r\n      if (potential.child2.isLeaf) {\r\n        cost2 = getSize(potential.child2.aabb) + inherCost;\r\n      } else {\r\n        cost2 =\r\n          getSize(getBoundAabb(leaf.aabb, potential.child2.aabb)) -\r\n          getSize(potential.child2.aabb) +\r\n          inherCost;\r\n      }\r\n      if (cost < cost1 && cost < cost2) return potential;\r\n      if (cost1 < cost2) {\r\n        potential = potential.child1;\r\n      } else potential = potential.child2;\r\n    }\r\n    return potential;\r\n  }\r\n  insertLeaf(aabb, gameObject) {\r\n    const leaf = new Node(aabb, true, gameObject);\r\n    if (this.root === null) {\r\n      this.root = leaf;\r\n      this.root.parent = null;\r\n      return leaf;\r\n    }\r\n\r\n    const sibling = this.getBestSibling(leaf);\r\n    const oldParent = sibling.parent;\r\n    const newParent = new Node(leaf.aabb, false);\r\n    newParent.parent = oldParent;\r\n\r\n    newParent.aabb = getBoundAabb(leaf.aabb, sibling.aabb);\r\n\r\n    if (oldParent) {\r\n      if (oldParent.child1 === sibling) oldParent.child1 = newParent;\r\n      else oldParent.child2 = newParent;\r\n\r\n      newParent.child1 = sibling;\r\n      newParent.child2 = leaf;\r\n\r\n      sibling.parent = newParent;\r\n      leaf.parent = newParent;\r\n    } else {\r\n      newParent.child1 = sibling;\r\n      newParent.child2 = leaf;\r\n\r\n      sibling.parent = newParent;\r\n      leaf.parent = newParent;\r\n      this.root = newParent;\r\n    }\r\n    let index = leaf.parent;\r\n\r\n    while (index) {\r\n      index = this.rebalance(index);\r\n      index = index.parent;\r\n    }\r\n    return leaf;\r\n  }\r\n  getCollisions(leaf) {\r\n    const cols = [];\r\n    const iter = (_node) => {\r\n      if (!_node) {\r\n        return;\r\n      }\r\n      if (_node === leaf) {\r\n        return;\r\n      }\r\n      if (isCollide(leaf.aabb, _node.aabb)) {\r\n        if (_node.isLeaf && !_node.isChecked) {\r\n          cols.push(_node.gameObject);\r\n        }\r\n        iter(_node.child1);\r\n        iter(_node.child2);\r\n      }\r\n    };\r\n\r\n    iter(this.root);\r\n\r\n    return cols;\r\n  }\r\n  removeLeaf(leaf) {\r\n    if (leaf === this.root) {\r\n      this.root = null;\r\n      return;\r\n    }\r\n    const parent = leaf.parent;\r\n    const grandParent = parent ? parent.parent : null;\r\n    let sibling;\r\n    if (parent.child1 === leaf) sibling = parent.child2;\r\n    else sibling = parent.child1;\r\n\r\n    if (grandParent) {\r\n      if (grandParent.child1 === parent) grandParent.child1 = sibling;\r\n      else grandParent.child2 = sibling;\r\n\r\n      sibling.parent = grandParent;\r\n\r\n      let index = grandParent;\r\n      while (index) {\r\n        index = this.rebalance(index);\r\n\r\n        index = index.parent;\r\n      }\r\n    } else {\r\n      this.root = sibling;\r\n      sibling.parent = null;\r\n    }\r\n  }\r\n  rebalance(leaf) {\r\n    if (!leaf) {\r\n      return null;\r\n    }\r\n    if (leaf.isLeaf || this.getHeight(leaf) < 2) {\r\n      leaf.aabb = getBoundAabb(leaf.child1.aabb, leaf.child2.aabb);\r\n      return leaf;\r\n    }\r\n    const child1 = leaf.child1;\r\n    const child2 = leaf.child2;\r\n    const balance = this.getHeight(child2) - this.getHeight(child1);\r\n\r\n    if (balance > 1) {\r\n      const child2Child1 = child2.child1;\r\n      const child2Child2 = child2.child2;\r\n\r\n      child2.child1 = leaf;\r\n      child2.parent = leaf.parent;\r\n      leaf.parent = child2;\r\n      if (child2.parent != null) {\r\n        if (child2.parent.child1 === leaf) {\r\n          child2.parent.child1 = child2;\r\n        } else {\r\n          child2.parent.child2 = child2;\r\n        }\r\n      } else this.root = child2;\r\n      if (this.getHeight(child2Child1) > this.getHeight(child2Child2)) {\r\n        child2.child2 = child2Child1;\r\n        leaf.child2 = child2Child2;\r\n        child2Child2.parent = leaf;\r\n      } else {\r\n        leaf.child2 = child2Child1;\r\n        child2Child1.parent = leaf;\r\n      }\r\n      leaf.aabb = getBoundAabb(leaf.child1.aabb, leaf.child2.aabb);\r\n      child2.aabb = getBoundAabb(child2.child1.aabb, child2.child2.aabb);\r\n\r\n      return child2;\r\n    }\r\n    if (balance < -1) {\r\n      const child1Child1 = child1.child1;\r\n      const child1Child2 = child1.child2;\r\n\r\n      child1.child1 = leaf;\r\n      child1.parent = leaf.parent;\r\n      leaf.parent = child1;\r\n\r\n      if (child1.parent != null) {\r\n        if (child1.parent.child1 === leaf) {\r\n          child1.parent.child1 = child1;\r\n        } else {\r\n          child1.parent.child2 = child1;\r\n        }\r\n      } else this.root = child1;\r\n      if (this.getHeight(child1Child1) > this.getHeight(child1Child2)) {\r\n        child1.child2 = child1Child1;\r\n        leaf.child1 = child1Child2;\r\n        child1Child2.parent = leaf;\r\n      } else {\r\n        child1.child2 = child1Child2;\r\n        leaf.child1 = child1Child1;\r\n        child1Child1.parent = leaf;\r\n      }\r\n      leaf.aabb = getBoundAabb(leaf.child1.aabb, leaf.child2.aabb);\r\n      child1.aabb = getBoundAabb(child1.child1.aabb, child1.child2.aabb);\r\n\r\n      return child1;\r\n    }\r\n    leaf.aabb = getBoundAabb(leaf.child1.aabb, leaf.child2.aabb);\r\n    return leaf;\r\n  }\r\n  toArray(i) {\r\n    const iter = (leaf, level) => {\r\n      if (!leaf) {\r\n        return null;\r\n      }\r\n      if (leaf.isLeaf) return leaf.objectLink.name;\r\n      else return [iter(leaf.child1), iter(leaf.child2)];\r\n    };\r\n    if (!i) i = this.root;\r\n    return iter(i);\r\n  }\r\n  getHeight(leaf) {\r\n    const iter = (leaf, level) => {\r\n      if (!leaf) {\r\n        return level;\r\n      }\r\n\r\n      let h1 = iter(leaf.child1, level + 1);\r\n      let h2 = iter(leaf.child2, level + 1);\r\n      return h1 > h2 ? h1 : h2;\r\n    };\r\n    return iter(leaf, 1);\r\n  }\r\n  getNodes() {\r\n    const iter = (node, arr) => {\r\n      arr.push(node);\r\n      if (node.child1) iter(node.child1, arr);\r\n      if (node.child2) iter(node.child2, arr);\r\n    };\r\n    const a = [];\r\n    iter(this.root, a);\r\n    return a;\r\n  }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { m4, vector } from \"math\";\r\n\r\nconst cPos = [0, 0, 5];\r\nconst cRot = [0, 0, 0];\r\nconst controls = {\r\n  ArrowDown: () => (cRot[0] -= 0.1),\r\n  ArrowUp: () => (cRot[0] += 0.1),\r\n  ArrowLeft: () => (cRot[1] += 0.1),\r\n  ArrowRight: () => (cRot[1] -= 0.1),\r\n  w: () => {\r\n    const delta = m4.transformPoint(\r\n      m4.xRotate(m4.yRotation(cRot[1]), cRot[0]),\r\n      [0, 0, -1]\r\n    );\r\n    cPos[0] += delta[0];\r\n    cPos[1] += delta[1];\r\n    cPos[2] += delta[2];\r\n  },\r\n  s: () => {\r\n    const delta = m4.transformPoint(\r\n      m4.xRotate(m4.yRotation(cRot[1]), cRot[0]),\r\n      [0, 0, 1]\r\n    );\r\n    cPos[0] += delta[0];\r\n    cPos[1] += delta[1];\r\n    cPos[2] += delta[2];\r\n  },\r\n  a: () => {\r\n    const delta = m4.transformPoint(\r\n      m4.xRotate(m4.yRotation(cRot[1]), cRot[0]),\r\n      [-1, 0, 0]\r\n    );\r\n    cPos[0] += delta[0];\r\n    cPos[1] += delta[1];\r\n    cPos[2] += delta[2];\r\n  },\r\n  d: () => {\r\n    const delta = m4.transformPoint(\r\n      m4.xRotate(m4.yRotation(cRot[1]), cRot[0]),\r\n      [1, 0, 0]\r\n    );\r\n    cPos[0] += delta[0];\r\n    cPos[1] += delta[1];\r\n    cPos[2] += delta[2];\r\n  },\r\n};\r\nconst mouseControls = {\r\n  lastX: 0,\r\n  lastY: 0,\r\n  mousemove: function (e) {\r\n    const deltaX = e.offsetX - this.lastX;\r\n    this.lastX = e.offsetX;\r\n    const deltaY = e.offsetY - this.lastY;\r\n    this.lastY = e.offsetY;\r\n\r\n    cRot[1] -= deltaX * 0.005;\r\n    cRot[0] -= deltaY * 0.005;\r\n  },\r\n};\r\ndocument.onkeydown = (e) => {\r\n  if (!controls[e.key]) return;\r\n  controls[e.key]();\r\n};\r\ndocument.onmousedown = (e) => {\r\n  mouseControls.lastY = e.offsetY;\r\n  mouseControls.lastX = e.offsetX;\r\n  document.onmousemove = mouseControls.mousemove.bind(mouseControls);\r\n  document.onmouseup = () => {\r\n    document.onmousemove = null;\r\n  };\r\n};\r\nlet cameraMatrix = m4.translation(...cPos);\r\ncameraMatrix = m4.yRotate(cameraMatrix, cRot[1]);\r\ncameraMatrix = m4.xRotate(cameraMatrix, cRot[0]);\r\n\r\nimport {\r\n  ArrayDataFromGltf,\r\n  PrimitiveRenderInfoFromArrayData,\r\n  EntityDataFromGltf,\r\n  getGlContext,\r\n  resizeCanvasToDisplaySize,\r\n  ProgramInfo,\r\n  MeshRenderer,\r\n  Drawer,\r\n  createBox,\r\n  PrimitiveRenderer,\r\n  Texture,\r\n  makeImgFromSvgXml,\r\n  makeStripeImg,\r\n  Entity,\r\n  GLTF,\r\n  GLcontextWrapper,\r\n  createCone,\r\n  createCircle,\r\n  defaultProgram,\r\n} from \"graphics\";\r\n\r\nconst context = new GLcontextWrapper(\"canvas\");\r\nconst gl = context.getContext();\r\ncontext.resizeCanvasToDisplaySize();\r\nconst drawer = new Drawer();\r\ndrawer.setContext(context).update3DProjectionMatrix();\r\n\r\ndefaultProgram.setContext(context).compileShaders().createUniformSetters();\r\n\r\nconst box = new PrimitiveRenderer(createBox(1, 1, 1));\r\n\r\nconst circle = new PrimitiveRenderer(createCircle(5, 10));\r\n\r\nconst points = new PrimitiveRenderer({\r\n  mode: gl.POINTS,\r\n  numElements: 2,\r\n  offset: 0,\r\n});\r\nconst line = new PrimitiveRenderer({\r\n  mode: gl.LINES,\r\n  numElements: 2,\r\n  offset: 0,\r\n});\r\n\r\nbox\r\n  .setContext(context)\r\n  .createVAO()\r\n  .setDrawer(drawer)\r\n  .setProgramInfo(defaultProgram)\r\n  .createGeometryBuffers()\r\n  .setAttributes()\r\n  .setMode(2);\r\n\r\ncircle\r\n  .setContext(context)\r\n  .createVAO()\r\n  .setDrawer(drawer)\r\n  .setProgramInfo(defaultProgram)\r\n  .createGeometryBuffers()\r\n  .setAttributes()\r\n  .setMode(3);\r\n\r\nline\r\n  .setContext(context)\r\n  .createVAO()\r\n  .setDrawer(drawer)\r\n  .setProgramInfo(defaultProgram)\r\n  .createBufferAttribData(\"a_position\", \"vec3\", { location: 0 })\r\n  .setOwnAttribute(\"a_position\")\r\n  .bufferData(\"a_position\", new Float32Array([0, 0, 0, 1, 2, 0]));\r\n\r\npoints\r\n  .setContext(context)\r\n  .createVAO()\r\n  .setDrawer(drawer)\r\n  .setProgramInfo(defaultProgram)\r\n  .createBufferAttribData(\"a_position\", \"vec3\", { location: 0 })\r\n  .setOwnAttribute(\"a_position\")\r\n  .bufferData(\"a_position\", new Float32Array([0, 0, 0]));\r\n\r\n/*\r\nconst uniforms = {\r\n  u_lightWorldPosition: [0, 0, 10],\r\n  u_ambientLight: [1, 1, 0.3, 0.11],\r\n  u_reverseLightDirection: [1, 0, 0],\r\n  u_shininess: 300,\r\n};\r\n*/\r\n\r\nimport Simulation from \"./src/simulation\";\r\nimport { Physics } from \"./src/physics\";\r\nimport { Box } from \"./src/collider\";\r\n\r\nconst sim = new Simulation();\r\n\r\nconst floor = { physics: new Physics(new Box(100, 2, 100)), sprite: box };\r\nconst cube = { physics: new Physics(new Box(5, 5, 5)), sprite: box };\r\nconst cube2 = { physics: new Physics(new Box(5, 5, 5)), sprite: box };\r\ncube.physics.translate([0, 5, 0]);\r\ncube2.physics.translate([0, 10, 0]);\r\n//cube.physics.rotate([Math.PI/4,Math.PI/4,Math.PI/4])\r\ncube.physics.addAcceleration([0, -9.8, 0]);\r\n\r\ncube2.physics.addAcceleration([0, -9.8, 0]);\r\n\r\nsim.addObject(floor.physics);\r\nsim.addObject(cube.physics);\r\nsim.addObject(cube2.physics);\r\n\r\nfloor.physics.setMass(1000000000);\r\n\r\nconst objects = [floor, cube, cube2];\r\n\r\nfloor.physics.translate([0, -2, 0]);\r\n//floor.physics.rotate([0.0,0,0])\r\n\r\n//document.addEventListener('click', sim.tick.bind(sim, 0.015))\r\nlet lastCall = Date.now();\r\nconst fps = document.querySelector(\"#fps\");\r\nlet i = 0;\r\nconst loop = () => {\r\n  sim.tick(0.015);\r\n\r\n  const curentTime = Date.now();\r\n  const delta = curentTime - lastCall;\r\n  fps.textContent = (1 / delta) * 1000;\r\n  lastCall = curentTime;\r\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n  gl.enable(gl.CULL_FACE);\r\n  gl.enable(gl.DEPTH_TEST);\r\n\r\n  cameraMatrix = m4.translation(...cPos);\r\n  cameraMatrix = m4.yRotate(cameraMatrix, cRot[1]);\r\n  cameraMatrix = m4.xRotate(cameraMatrix, cRot[0]);\r\n  i += 0.001;\r\n\r\n  const manifolds = sim.collisionManifolds.values();\r\n  for (const manifold of manifolds) {\r\n    manifold.contacts.forEach((contact) => {\r\n      points\r\n        .draw({\r\n          u_matrix: m4.translation(...contact.PA),\r\n          u_color: [0, 1, 0, 1],\r\n        }, cameraMatrix)\r\n        .draw({\r\n          u_matrix: m4.translation(...contact.PB),\r\n          u_color: [1, 1, 0, 1],\r\n        }, cameraMatrix);\r\n    });\r\n  }\r\n\r\n  objects.forEach((obj) => {\r\n    const scale = vector.diff(\r\n      obj.physics.collider.max,\r\n      obj.physics.collider.min\r\n    );\r\n    const u_matrix = m4.scale(obj.physics.collider.getM4(), ...scale);\r\n    obj.sprite.draw({ u_color: [1, 0, 1, 1], u_matrix }, cameraMatrix);\r\n  });\r\n\r\n  circle.draw(\r\n    {\r\n      u_matrix: m4.translation(0, 0, 0),\r\n      u_color: [1, 0.5, 0.1, 1],\r\n      u_worldViewPosition: cameraMatrix,\r\n    },\r\n    cameraMatrix\r\n  );\r\n\r\n  line.draw(\r\n    {\r\n      u_matrix: m4.translation(0, 0, 0),\r\n      u_color: [1, 0, 1, 1],\r\n      u_worldViewPosition: cameraMatrix,\r\n    },\r\n    cameraMatrix\r\n  );\r\n\r\n  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n  requestAnimationFrame(loop);\r\n};\r\nloop();\r\n"],"names":[],"sourceRoot":""}