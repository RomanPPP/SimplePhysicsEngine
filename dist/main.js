(()=>{var t={111:(t,s,e)=>{const i=e(195),r=e(187),o=e(464),{Node:n,TRS:a}=e(318),h=e(373);t.exports={AABB:i,m3:r,m4:o,Node:n,TRS:a,vector:h}},195:t=>{t.exports=class{constructor(t,s){this.min=t,this.max=s}}},187:t=>{const s={multiply:function(t,s){var e=s[0],i=s[1],r=s[2],o=s[3],n=s[4],a=s[5],h=s[6],c=s[7],l=s[8],u=t[0],d=t[1],m=t[2],f=t[3],p=t[4],b=t[5],g=t[6],y=t[7],v=t[8];return[u*e+d*o+m*h,u*i+d*n+m*c,u*r+d*a+m*l,f*e+p*o+b*h,f*i+p*n+b*c,f*r+p*a+b*l,g*e+y*o+v*h,g*i+y*n+v*c,g*r+y*a+v*l]},xRotation:function(t){var s=Math.cos(t),e=Math.sin(t);return[1,0,0,0,s,e,0,-e,s]},yRotation:function(t){var s=Math.cos(t),e=Math.sin(t);return[s,0,-e,0,1,0,e,0,s]},zRotation:function(t){var s=Math.cos(t),e=Math.sin(t);return[s,e,0,-e,s,0,0,0,1]},m3Tom4:function(t){const s=new Float32Array(16);return s[0]=t[0],s[1]=t[1],s[2]=t[2],s[3]=0,s[4]=t[3],s[5]=t[4],s[6]=t[5],s[7]=0,s[8]=t[6],s[9]=t[7],s[10]=t[8],s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,s},xRotate:function(t,e){return s.multiply(t,s.xRotation(e))},yRotate:function(t,e){return s.multiply(t,s.yRotation(e))},zRotate:function(t,e){return s.multiply(t,s.zRotation(e))},transformPoint:function(t,s,e){e=e||new Float32Array(3);var i=s[0],r=s[1],o=s[2];return e[0]=i*t[0]+r*t[3]+o*t[6],e[1]=i*t[1]+r*t[4]+o*t[7],e[2]=i*t[2]+r*t[5]+o*t[8],e},identity:function(){return[1,0,0,0,1,0,0,0,1]},transpose:function(t){return dst=new Float32Array(9),dst[0]=t[0],dst[1]=t[3],dst[2]=t[6],dst[3]=t[1],dst[4]=t[4],dst[5]=t[7],dst[6]=t[2],dst[7]=t[5],dst[8]=t[8],dst},scaling:function(t,s,e){return new Float32Array([t,0,0,0,s,0,0,0,e])},scale:function(t,e,i,r){return s.multiply(t,s.scaling(e,i,r))},inverse:function(t){const s=t[0]*t[4]*t[8]+t[2]*t[3]*t[7]+t[1]*t[5]*t[6]-t[2]*t[4]*t[6]-t[0]*t[5]*t[7]-t[8]*t[3]*t[2],e=new Float32Array(9);e[0]=(t[4]*t[8]-t[7]*t[5])/s,e[1]=(t[3]*t[8]-t[6]*t[5])/s,e[2]=(t[3]*t[7]-t[6]*t[4])/s,e[3]=(t[1]*t[8]-t[2]*t[7])/s,e[4]=(t[0]*t[8]-t[2]*t[6])/s,e[5]=(t[0]*t[7]-t[1]*t[6])/s,e[6]=(t[1]*t[5]-t[2]*t[4])/s,e[7]=(t[0]*t[5]-t[2]*t[3])/s,e[8]=(t[0]*t[4]-t[1]*t[4])/s},toString:t=>t.reduce(((t,s,e)=>t+(e%3==0?"\n"+s:" "+s))),dot:(t,s)=>t[0]*s[0]+t[1]*s[1]+t[2]*s[2]};t.exports=s},464:(t,s,e)=>{const i=Float32Array,{norm:r}=e(373),o={multiply:function(t,s,e){e=e||new i(16);var r=t[0],o=t[1],n=t[2],a=t[3],h=t[4],c=t[5],l=t[6],u=t[7],d=t[8],m=t[9],f=t[10],p=t[11],b=t[12],g=t[13],y=t[14],v=t[15],x=s[0],w=s[1],A=s[2],R=s[3],_=s[4],M=s[5],E=s[6],P=s[7],I=s[8],T=s[9],V=s[10],L=s[11],S=s[12],B=s[13],N=s[14],J=s[15];return e[0]=x*r+w*h+A*d+R*b,e[1]=x*o+w*c+A*m+R*g,e[2]=x*n+w*l+A*f+R*y,e[3]=x*a+w*u+A*p+R*v,e[4]=_*r+M*h+E*d+P*b,e[5]=_*o+M*c+E*m+P*g,e[6]=_*n+M*l+E*f+P*y,e[7]=_*a+M*u+E*p+P*v,e[8]=I*r+T*h+V*d+L*b,e[9]=I*o+T*c+V*m+L*g,e[10]=I*n+T*l+V*f+L*y,e[11]=I*a+T*u+V*p+L*v,e[12]=S*r+B*h+N*d+J*b,e[13]=S*o+B*c+N*m+J*g,e[14]=S*n+B*l+N*f+J*y,e[15]=S*a+B*u+N*p+J*v,e},translation:function(t,s,e){return[1,0,0,0,0,1,0,0,0,0,1,0,t,s,e,1]},xRotation:function(t){var s=Math.cos(t),e=Math.sin(t);return[1,0,0,0,0,s,e,0,0,-e,s,0,0,0,0,1]},yRotation:function(t){var s=Math.cos(t),e=Math.sin(t);return[s,0,-e,0,0,1,0,0,e,0,s,0,0,0,0,1]},zRotation:function(t){var s=Math.cos(t),e=Math.sin(t);return[s,e,0,0,-e,s,0,0,0,0,1,0,0,0,0,1]},scaling:function(t,s,e){return[t,0,0,0,0,s,0,0,0,0,e,0,0,0,0,1]},translate:function(t,s,e,i){return o.multiply(t,o.translation(s,e,i))},xRotate:function(t,s){return o.multiply(t,o.xRotation(s))},yRotate:function(t,s){return o.multiply(t,o.yRotation(s))},zRotate:function(t,s){return o.multiply(t,o.zRotation(s))},scale:function(t,s,e,i){return o.multiply(t,o.scaling(s,e,i))},makeOrt:function(t){const s=[0,0,0],e=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);return s[0]=t[0]/e,s[1]=t[1]/e,s[2]=t[2]/e,s},projection:function(t,s,e){return[2/t,0,0,0,0,-2/s,0,0,0,0,2/e,0,-1,1,0,1]},perspective:function(t,s,e,i){var r=Math.tan(.5*Math.PI-.5*t),o=1/(e-i);return[r/s,0,0,0,0,r,0,0,0,0,(e+i)*o,-1,0,0,e*i*o*2,0]},inverse:function(t){var s=t[0],e=t[1],i=t[2],r=t[3],o=t[4],n=t[5],a=t[6],h=t[7],c=t[8],l=t[9],u=t[10],d=t[11],m=t[12],f=t[13],p=t[14],b=t[15],g=u*b,y=p*d,v=a*b,x=p*h,w=a*d,A=u*h,R=i*b,_=p*r,M=i*d,E=u*r,P=i*h,I=a*r,T=c*f,V=m*l,L=o*f,S=m*n,B=o*l,N=c*n,J=s*f,C=m*e,F=s*l,D=c*e,U=s*n,O=o*e,j=g*n+x*l+w*f-(y*n+v*l+A*f),k=y*e+R*l+E*f-(g*e+_*l+M*f),z=v*e+_*n+P*f-(x*e+R*n+I*f),X=A*e+M*n+I*l-(w*e+E*n+P*l),Y=1/(s*j+o*k+c*z+m*X);return[Y*j,Y*k,Y*z,Y*X,Y*(y*o+v*c+A*m-(g*o+x*c+w*m)),Y*(g*s+_*c+M*m-(y*s+R*c+E*m)),Y*(x*s+R*o+I*m-(v*s+_*o+P*m)),Y*(w*s+E*o+P*c-(A*s+M*o+I*c)),Y*(T*h+S*d+B*b-(V*h+L*d+N*b)),Y*(V*r+J*d+D*b-(T*r+C*d+F*b)),Y*(L*r+C*h+U*b-(S*r+J*h+O*b)),Y*(N*r+F*h+O*d-(B*r+D*h+U*d)),Y*(L*u+N*p+V*a-(B*p+T*a+S*u)),Y*(F*p+T*i+C*u-(J*u+D*p+V*i)),Y*(J*a+O*p+S*i-(U*p+L*i+C*a)),Y*(U*u+B*i+D*a-(F*a+O*u+N*i))]},lookAt:function(t,s,e){var i=normalize(subtractVectors(t,s)),r=normalize(cross(e,i)),o=normalize(cross(i,r));return[r[0],r[1],r[2],0,o[0],o[1],o[2],0,i[0],i[1],i[2],0,t[0],t[1],t[2],1]},copy:function(t){const s=new i(16);return s[0]=t[0],s[1]=t[1],s[2]=t[2],s[3]=t[3],s[4]=t[4],s[5]=t[5],s[6]=t[6],s[7]=t[7],s[8]=t[8],s[9]=t[9],s[10]=t[10],s[11]=t[11],s[12]=t[12],s[13]=t[13],s[14]=t[14],s[15]=t[15],s},vectorSum:function(t,s){const e=[0,0,0];return e[0]=t[0]+s[0],e[1]=t[1]+s[1],e[2]=t[2]+s[2],e},cross:function(t,s){return[t[1]*s[2]-t[2]*s[1],t[2]*s[0]-t[0]*s[2],t[0]*s[1]-t[1]*s[0]]},vectorScalarProduct(t,s){let e=[0,0,0];return e[0]=t[0]*s,e[1]=t[1]*s,e[2]=t[2]*s,isNaN(e[0])||isNaN(e[2])||isNaN(e[2])?[0,0,0]:e},scalarProduct:function(t,s){return t[0]*s[0]+t[1]*s[1]+t[2]*s[2]},dot:(t,s)=>t[0]*s[0]+t[1]*s[1]+t[2]*s[2],isNullVector:function(t){return!t[0]&&!t[1]&&!t[2]},getVectorLength:t=>Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]),transformPoint:function(t,s,e){e=e||new i(3);var r=s[0],o=s[1],n=s[2],a=r*t[3]+o*t[7]+n*t[11]+t[15];return e[0]=(r*t[0]+o*t[4]+n*t[8]+t[12])/a,e[1]=(r*t[1]+o*t[5]+n*t[9]+t[13])/a,e[2]=(r*t[2]+o*t[6]+n*t[10]+t[14])/a,e},normalize:function(t,s){s=s||new i(3);var e=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);return e>1e-5&&(s[0]=t[0]/e,s[1]=t[1]/e,s[2]=t[2]/e),s},identity:function(){return dst=new i(16),dst[0]=1,dst[1]=0,dst[2]=0,dst[3]=0,dst[4]=0,dst[5]=1,dst[6]=0,dst[7]=0,dst[8]=0,dst[9]=0,dst[10]=1,dst[11]=0,dst[12]=0,dst[13]=0,dst[14]=0,dst[15]=1,dst},m3Tom4:function(t){const s=new i(16);return s[0]=t[0],s[1]=t[1],s[2]=t[2],s[3]=0,s[4]=t[3],s[5]=t[4],s[6]=t[5],s[7]=0,s[8]=t[6],s[9]=t[7],s[10]=t[8],s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,s},m4Tom3:function(t){const s=new i(9);return s[0]=t[0],s[1]=t[1],s[2]=t[2],s[3]=t[4],s[4]=t[5],s[5]=t[6],s[6]=t[8],s[7]=t[9],s[8]=t[10],s},toString:t=>t.reduce(((t,s,e)=>t+(e%4==0?"\n"+s:" "+s))),transpose:function(t){return[t[0],t[4],t[8],t[12],t[1],t[5],t[9],t[13],t[2],t[6],t[10],t[14],t[3],t[7],t[11],t[15]]},fromQuaternion:t=>[1-2*(t[1]*t[1]+t[2]*t[2]),2*(t[0]*t[1]-t[2]*t[3]),2*(t[0]*t[2]+t[1]*t[3]),0,2*(t[0]*t[1]+t[2]*t[3]),1-2*(t[0]*t[0]+t[2]*t[2]),2*(t[1]*t[2]-t[0]*t[3]),0,2*(t[0]*t[2]-t[1]*t[3]),2*(t[1]*t[2]+t[0]*t[3]),1-2*(t[0]*t[0]+t[1]*t[1]),0,0,0,0,1],rotation(t,s,e){return this.xRotate(this.yRotate(this.zRotation(e),s),t)},rotationFromNormal(t){return this.rotation(Math.acos(t[1]),Math.acos(t[2]),Math.acos(t[0]))},determinate(t){var s=t[0],e=t[1],i=t[2],r=t[3],o=t[4],n=t[5],a=t[6],h=t[7],c=t[8],l=t[9],u=t[10],d=t[11],m=t[12],f=t[13],p=t[14],b=t[15],g=u*b,y=p*d,v=a*b,x=p*h,w=a*d,A=u*h,R=i*b,_=p*r,M=i*d,E=u*r,P=i*h,I=a*r;return 1/(s*(g*n+x*l+w*f-(y*n+v*l+A*f))+o*(y*e+R*l+E*f-(g*e+_*l+M*f))+c*(v*e+_*n+P*f-(x*e+R*n+I*f))+m*(A*e+M*n+I*l-(w*e+E*n+P*l)))},decompose(t){let s=r(t.slice(0,3));const e=r(t.slice(4,7)),i=r(t.slice(8,11));this.determinate(t)<0&&(s=-s);const o=[],n=[],a=[...t];o[0]=t[12],o[1]=t[13],o[2]=t[14];const h=1/s,c=1/e,l=1/i;return a[0]*=h,a[1]*=h,a[2]*=h,a[4]*=c,a[5]*=c,a[6]*=c,a[8]*=l,a[9]*=l,a[10]*=l,n[0]=s,n[1]=e,n[2]=i,{translation:o,Rmatrix:a,scale:n}}};t.exports=o},318:(t,s,e)=>{const i=e(464);class r{constructor(t,s,e){this.translation=t,this.rotation=s,this.scale=e}getMatrix(t){let s=t||i.identity();var e=this.translation,r=this.rotation,o=this.scale;return Math.sin(r[3]/2),Math.cos(r[3]/2),s=i.translate(s,e[0],e[1],e[2]),s=i.multiply(s,i.fromQuaternion(r)),s=i.scale(s,o[0],o[1],o[2]),s}getRMatrix(){let t=i.identity();var s=this.rotation;return t=i.xRotate(t,s[0]),t=i.yRotate(t,s[1]),t=i.zRotate(t,s[2]),t}getTRmatrix(){const t=this.translation,s=this.rotation;let e=i.translation(t[0],t[1],t[2]);return e=i.xRotate(e,s[0]),e=i.yRotate(e,s[1]),e=i.zRotate(e,s[2]),e}}t.exports={Node:class{constructor(t,s=new r){this.worldMatrix=i.identity(),this.parent=null,this.children=[],this.trs=s,this.name=t,this.parts=[]}setParent(t){if(this.parent){const t=this.parent.children.indexOf(this);t>=0&&this.parent.children.splice(t,1)}t&&t.children.push(this),this.parent=t}updateWorldMatrix(t){let s=this.trs.getMatrix();t&&(s=i.multiply(t,s)),this.worldMatrix=s,this.children.forEach((t=>{t.updateWorldMatrix(s)}))}updatePartsList(){const t=(s,e)=>{e.push(s),s.children.forEach((s=>t(s,e)))};t(this,this.parts)}},TRS:r}},373:t=>{const s=(t,s)=>t[0]*s[0]+t[1]*s[1]+t[2]*s[2],e=(t,s)=>[t[0]*s,t[1]*s,t[2]*s],i=(t,s)=>[t[0]+s[0],t[1]+s[1],t[2]+s[2]],r=(t,s)=>[t[0]-s[0],t[1]-s[1],t[2]-s[2]],o=t=>Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]),n=t=>t[0]*t[0]+t[1]*t[1]+t[2]*t[2],a=t=>isNaN(t[0]+t[1]+t[2])||t[0]+t[1]+t[2]===1/0||t[0]+t[1]+t[2]===-1/0;t.exports={chkV:t=>{if(a(t))throw console.log(t),new Error("NaN Vec")},dot:(t,e)=>{if(a(t)||a(e))throw console.log(t,e),new Error("args is NaN : ,");return s(t,e)},cross:(t,s)=>{if(a(t)||a(s))throw console.log(t,s),new Error("args is NaN : ,");const e=((t,s)=>{const e=[t[1]*s[2]-s[1]*t[2],t[2]*s[0]-s[2]*t[0],t[0]*s[1]-s[0]*t[1]];if(a(t)||a(s))throw console.log(t,s),new Error("args is NaN : ,");return e})(t,s);if(a(e))throw console.log(t,s),new Error("get NaN : ,");return e},scale:(t,s)=>{if(a(t)||isNaN(s))throw console.log(t,s),new Error("args is NaN : ,");const i=e(t,s);if(a(i))throw console.log(t,s),new Error("get NaN : ,");return i},sum:(t,s)=>{if(a(t)||a(s))throw console.log(t,s),new Error("args is NaN : ,");const e=i(t,s);if(a(e))throw console.log(t,s),new Error("get NaN : ,");return e},diff:(t,s)=>{if(a(t)||a(s))throw console.log(t,s),new Error("args is NaN : ,");const e=r(t,s);if(a(e))throw console.log(t,s),new Error("get NaN : ,");return e},normalize:t=>{if(a(t))throw console.log(t),new Error("args is NaN : ,");const s=(t=>{const s=o(t);return 0===s?t:[t[0]/s,t[1]/s,t[2]/s]})(t);if(a(s))throw console.log(t),new Error("get NaN : ,");return s},norm:o,normSq:n,isNull:t=>t[0]*t[0]+t[1]*t[1]+t[2]*t[2]==0,findFurthestPoint:(t,s,e)=>{const i=n(r(t,s)),o=n(r(t,e)),a=n(r(e,s));return i<o?i<a?e:s:o<a?s:t},distanceFromLine:(t,o,a)=>{const h=r(a,t),c=r(o,t),l=s(c,h)/n(c),u=i(t,e(c,l));return n(r(a,u))},isEqual:(t,s)=>t[0]==s[0]&&t[1]==s[1]&&t[2]==s[2]}}},s={};function e(i){var r=s[i];if(void 0!==r)return r.exports;var o=s[i]={exports:{}};return t[i](o,o.exports,e),o.exports}(()=>{"use strict";var t=e(111);const s={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5124:Int32Array,5125:Uint32Array,5126:Float32Array},i=t=>{const{numComponents:e,type:i,location:r,numAttributes:o,stride:n,offset:a,buffer:h,gl:c,divisor:l}=t;c.bindBuffer(c.ARRAY_BUFFER,h);for(let t=0;t<o;t++){const o=e*t*s[i].BYTES_PER_ELEMENT;c.enableVertexAttribArray(r+t),c.vertexAttribIPointer(r+t,e,i,!1,n,a+o),l&&c.vertexAttribDivisor(r+t,l)}},r={};r[5120]=i,r[5126]=t=>{const{numComponents:e,type:i,location:r,numAttributes:o,stride:n,offset:a,buffer:h,gl:c,divisor:l}=t;c.bindBuffer(c.ARRAY_BUFFER,h);for(let t=0;t<o;t++){const o=e*t*s[i].BYTES_PER_ELEMENT;c.enableVertexAttribArray(r+t),c.vertexAttribPointer(r+t,e,i,!1,n,a+o),l&&c.vertexAttribDivisor(r+t,l)}},r[5121]=i,r[5124]=i,r[5125]=i,r[5122]=i,r[5123]=i;class o{constructor(t,s){this.gl=t,this.buffer=t.createBuffer(),this.stride=s.stride||0,this.numComponents=s.numComponents,this.numAttributes=s.numAttributes||1,this.offset=s.offset||0,this.type=s.type,this.location=s.location,this.divisor=s.divisor}setAttribute(){const{type:t,gl:s}=this;(0,r[t])(this)}bufferData(t,s,e=35044){const{gl:i,buffer:r}=this;i.bindBuffer(i.ARRAY_BUFFER,r),i.bufferData(i.ARRAY_BUFFER,t||s,e)}bufferSubData(t,s=0){const{gl:e,buffer:i}=this;e.bindBuffer(e.ARRAY_BUFFER,i),e.bufferSubData(e.ARRAY_BUFFER,s,t)}}const n={mat4:{stride:64,byteLength:64,type:5126,numAttributes:4,numComponents:4},vec3:{numComponents:3,type:5126,numAttributes:1}},a=t=>n[t],h=class{constructor(t){this.buffers={},this.programInfo=null,this.context=null,this.drawer=null,this.mode=null,this.offset=null,this.numElements=null,this.vao=null,this.componentType=null,this.arrayData=t;const{componentType:s,numElements:e,mode:i}=t;this.numElements=e,this.mode=i,this.componentType=s||5123}setContext(t){return this.context=t,this}createVAO(){if(!this.vao)return this.vao=this.context.gl.createVertexArray(),this}setMode(t){return this.mode=t,this}createGeometryBuffers(){const{arrayData:t}=this,{gl:s}=this.context,{attributes:e,indices:i,componentType:r,numElements:n,mode:a}=t;if(e&&Object.keys(e).forEach((t=>{const{stride:i,type:r,offset:n,location:a,numComponents:h,numAttributes:c,data:l,size:u}=e[t],d=new o(s,{stride:i,type:r,offset:n,location:a,numAttributes:c,numComponents:h,size:u});d.bufferData(l),this.buffers={...this.buffers,[t]:d}})),i){const t=s.createBuffer();s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,t),s.bufferData(s.ELEMENT_ARRAY_BUFFER,i,s.STATIC_DRAW),this.indices=t}return this}setAttributes(){const{gl:t}=this.context;t.bindVertexArray(this.vao);for(const t in this.buffers)this.buffers[t].setAttribute();return t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indices),t.bindVertexArray(null),this}setDrawer(t){return this.drawer=t,this}setProgramInfo(t){return this.programInfo=t,this}createBufferAttribData(t,s,e){const{gl:i}=this.context,r={...a(s),...e},n=new o(i,r);return this.buffers={...this.buffers,[t]:n},this}setBufferAttribData(t,s){return this.buffers={...this.buffers,[t]:s},this}setOwnAttribute(t,s){const{gl:e}=this.context,i=this.buffers[t];return e.bindVertexArray(this.vao),i.setAttribute(s),e.bindVertexArray(null),this}setAttribute(t){const{gl:s}=this.context;return s.bindVertexArray(this.vao),t.setAttribute(),s.bindVertexArray(null),this}bufferData(t,s,e,i){return this.buffers[t].bufferData(s,e,i),this}bufferSubData(t,s,e){return this.buffers[t].bufferSubData(s,e),this}draw(t,s){return this.drawer.draw(this,t,s),this}drawInstanced(t,s,e){return this.drawer.drawInstanced(this,t,s,e),this}};function c(t){let s=0;return t.push=function(){for(let e=0;e<arguments.length;++e){const i=arguments[e];if(i instanceof Array||i.buffer&&i.buffer instanceof ArrayBuffer)for(let e=0;e<i.length;++e)t[s++]=i[e];else t[s++]=i}},t}class l{constructor(t,s){this.vs=t,this.fs=s,this.VAO=null,this.uniformSetters=null,this.vertexShader=null,this.fragmentShader=null,this.program=null,this.gl=null}setContext(t){return this.context=t,this}createUniformSetters(){const{gl:t}=this.context,{uniformSetters:s,textureSetters:e}=function(t,s){const e=(s,e)=>{const i=t.getUniformLocation(s,e.name);return s=>{t.uniform1i(i,s)}};function i(s,e){const i=t.getUniformLocation(s,e.name),r=e.type,o=e.size>1&&"[0]"===e.name.substr(-3);return r===t.FLOAT&&o?function(s){t.uniform1fv(i,s)}:r===t.FLOAT?function(s){t.uniform1f(i,s)}:r===t.FLOAT_VEC2?function(s){t.uniform2fv(i,s)}:r===t.FLOAT_VEC3?function(s){t.uniform3fv(i,s)}:r===t.FLOAT_VEC4?function(s){t.uniform4fv(i,s)}:r===t.INT&&o?function(s){t.uniform1iv(i,s)}:r===t.INT?function(s){t.uniform1i(i,s)}:r===t.INT_VEC2?function(s){t.uniform2iv(i,s)}:r===t.INT_VEC3?function(s){t.uniform3iv(i,s)}:r===t.INT_VEC4?function(s){t.uniform4iv(i,s)}:r===t.BOOL?function(s){t.uniform1iv(i,s)}:r===t.BOOL_VEC2?function(s){t.uniform2iv(i,s)}:r===t.BOOL_VEC3?function(s){t.uniform3iv(i,s)}:r===t.BOOL_VEC4?function(s){t.uniform4iv(i,s)}:r===t.FLOAT_MAT2?function(s){t.uniformMatrix2fv(i,!1,s)}:r===t.FLOAT_MAT3?function(s){t.uniformMatrix3fv(i,!1,s)}:r===t.FLOAT_MAT4?function(s){t.uniformMatrix4fv(i,!1,s)}:void 0}const r={},o={},n=t.getProgramParameter(s,t.ACTIVE_UNIFORMS);for(let a=0;a<n;++a){const n=t.getActiveUniform(s,a);if(!n)break;let h=n.name;if(n.type!==t.SAMPLER_2D)if("[0]"===h.substr(-3)&&(h=h.substr(0,h.length-3)),n.size>1)for(let t=0;t<n.size;t++){const e={size:n.size,type:n.type,name:h+`[${t}]`};r[h+`[${t}]`]=i(s,e)}else{const t=i(s,n);r[h]=t}else o[h]=e(s,n)}return{uniformSetters:r,textureSetters:o}}(t,this.program);return this.textureSetters=e,this.uniformSetters=s,this}compileShaders(){const{gl:t}=this.context;if(this.vertexShader=t.createShader(t.VERTEX_SHADER),t.shaderSource(this.vertexShader,this.vs),t.compileShader(this.vertexShader),!t.getShaderParameter(this.vertexShader,t.COMPILE_STATUS))throw new Error(t.getShaderInfoLog(this.vertexShader));if(this.fragmentShader=t.createShader(t.FRAGMENT_SHADER),t.shaderSource(this.fragmentShader,this.fs),t.compileShader(this.fragmentShader),!t.getShaderParameter(this.fragmentShader,t.COMPILE_STATUS))throw new Error(t.getShaderInfoLog(this.fragmentShader));if(this.program=t.createProgram(),t.attachShader(this.program,this.vertexShader),t.attachShader(this.program,this.fragmentShader),t.linkProgram(this.program),!t.getProgramParameter(this.program,t.LINK_STATUS))throw new Error(t.getProgramInfoLog(this.program));return this}setUniforms(t){return this.context.useProgramInfo(this),Object.keys(t).forEach((s=>{const e=this.uniformSetters[s];e&&e(t[s])})),this}setTextureUniformUnit(t,s){this.context.useProgramInfo(this);const e=this.textureSetters[t];return e&&e(s),this}}e(373),new Uint16Array([0,1,1,2,2,3,3,0,0,5,5,4,4,1,1,0,0,4,4,7,7,3,3,0,1,2,2,6,6,5,5,1,4,5,5,6,6,7,7,4,2,7,7,3,3,6,6,2]);const u=[[3,7,5,1],[6,2,0,4],[6,7,3,2],[0,1,5,4],[7,6,4,5],[2,3,1,0]],d=t=>t*Math.PI/180,m=d(90),f=(t,s={})=>{const e=document.createElement("img");var i="data:image/svg+xml;base64,"+btoa(t);e.src=i;const r=s.width||100,o=s.height||100,n=s.x||1,a=s.y||50,h=document.createElement("canvas").getContext("2d");return((t,s,e)=>{t.canvas.width=s,t.canvas.height=e})(h,r,o),h.drawImage(e,n,a,r,o),h.fillStyle="rgba(0,0,0,1)",h.fillRect(0,0,r,o),h.img};class p{static makeImgFromSvgXml=f;constructor(t){this.texture=t.createTexture(),this.fromImage=s=>(t.bindTexture(t.TEXTURE_2D,this.texture),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,s),this),this.getTexture=()=>this.texture}}const b=t=>t,g=new l(b`#version 300 es

precision highp float;

uniform mat4 worldViewProjection;


layout(location = 0) in vec4 a_position;
void main() {
  gl_Position = worldViewProjection * a_position;
  gl_PointSize = 10.0;
}`,b`#version 300 es
precision highp float;
 


uniform vec4 u_color;
out vec4 outColor;
void main() {
  
  
  outColor = u_color;
 
  
  
}
`);new l(b`#version 300 es
 
layout(location = 0) in vec4 a_position;
layout(location = 1) in vec3 a_normal;

layout(location = 4) in vec2 a_texcoord;
layout(location = 5) in mat4 i_matrix;

uniform mat4 worldMatrix;
uniform mat4 worldViewProjection;
uniform vec3 u_lightWorldPosition;
uniform vec3 u_viewWorldPosition;

out vec3 v_normal;
out vec2 v_texcoord;
out vec3 v_surfaceToLight;
out vec3 v_surfaceToView;

void main() {

    vec3 surfaceWorldPosition = (worldMatrix * a_position).xyz;
    v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;

    vec4 pos =   worldViewProjection * a_position  ;
    gl_Position = pos;

    v_texcoord = a_texcoord;
    v_normal = mat3(   worldMatrix ) * a_normal;
    v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;
      
}`,b`#version 300 es
precision highp float;
 

in vec2 v_texcoord;

in vec3 v_normal;
in vec3 v_surfaceToView;
in vec3 v_surfaceToLight;


//uniform sampler2D u_texture1;
uniform float u_shininess;
uniform vec4 u_color;
uniform vec4 u_ambientLight;
out vec4 outColor;


void main() {
  
  vec3 surfaceToLightDirection = normalize(v_surfaceToLight);
  vec3 surfaceToViewDirection = normalize(v_surfaceToView);
  vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);

  vec3 normal = normalize(v_normal);
  float light = dot(v_normal, surfaceToLightDirection);
  float specular = 0.0;
  if (light > 0.0) {
    specular = pow(dot(normal, halfVector), u_shininess);
  }

  outColor =  u_color;
  outColor.rgb *= light;
  outColor.rgb += u_ambientLight.rgb *0.3;
  
}
`);class y{constructor(){this.events={}}on(t,s){return this.events[t]||(this.events[t]=[]),this.events[t].push(s),()=>{this.events[t]=this.events[t].filter((t=>s!==t))}}emit(t,s){this.events[t]&&this.events[t].forEach((t=>{t.call(null,s)}))}}const v=(s,e)=>{if(!s||!e)return 0;const i=s.min[0]<e.min[0]?s.min[0]:e.min[0],r=s.max[0]>e.max[0]?s.max[0]:e.max[0],o=s.min[1]<e.min[1]?s.min[1]:e.min[1],n=s.max[1]>e.max[1]?s.max[1]:e.max[1],a=s.min[2]<e.min[2]?s.min[2]:e.min[2],h=s.max[2]>e.max[2]?s.max[2]:e.max[2];return new t.AABB([i,o,a],[r,n,h])},x=t=>Math.abs(t.max[0]-t.min[0])*Math.abs(t.max[1]-t.min[1])*Math.abs(t.max[2]-t.min[2]);class w{constructor(t,s,e){this.aabb=t,this.isLeaf=s,this.parent=null,this.gameObject=e,this.isChecked=!1}}class A{constructor(){this.root=null,this.leafs={},this.unusedIndexes=[]}setUnchecked(){const t=[this.root];for(;0!=t.length;){const s=t.pop();s.isLeaf?s.isChecked=!1:(s.child1&&t.push(s.child1),s.child2&&t.push(s.child2))}}getBestSibling(t){let s=this.root;for(;!s.isLeaf;){const e=x(s.aabb),i=v(s.aabb,t.aabb),r=x(i);let o,n,a=r,h=r-e;if(o=s.child1.isLeaf?x(s.child1.aabb)+h:x(v(t.aabb,s.child1.aabb))-x(s.child1.aabb)+h,n=s.child2.isLeaf?x(s.child2.aabb)+h:x(v(t.aabb,s.child2.aabb))-x(s.child2.aabb)+h,a<o&&a<n)return s;s=o<n?s.child1:s.child2}return s}insertLeaf(t,s){const e=new w(t,!0,s);if(null===this.root)return this.root=e,this.root.parent=null,e;const i=this.getBestSibling(e),r=i.parent,o=new w(e.aabb,!1);o.parent=r,o.aabb=v(e.aabb,i.aabb),r?(r.child1===i?r.child1=o:r.child2=o,o.child1=i,o.child2=e,i.parent=o,e.parent=o):(o.child1=i,o.child2=e,i.parent=o,e.parent=o,this.root=o);let n=e.parent;for(;n;)n=this.rebalance(n),n=n.parent;return e}getCollisions(t){const s=[],e=i=>{var r,o;i&&i!==t&&(r=t.aabb,o=i.aabb,r.min[0]<=o.max[0]&&r.max[0]>=o.min[0]&&r.min[1]<=o.max[1]&&r.max[1]>=o.min[1]&&r.min[2]<=o.max[2]&&r.max[2]>=o.min[2]&&(i.isLeaf&&!i.isChecked&&s.push(i.gameObject),e(i.child1),e(i.child2)))};return e(this.root),s}removeLeaf(t){if(t===this.root)return void(this.root=null);const s=t.parent,e=s?s.parent:null;let i;if(i=s.child1===t?s.child2:s.child1,e){e.child1===s?e.child1=i:e.child2=i,i.parent=e;let t=e;for(;t;)t=this.rebalance(t),t=t.parent}else this.root=i,i.parent=null}rebalance(t){if(!t)return null;if(t.isLeaf||this.getHeight(t)<2)return t.aabb=v(t.child1.aabb,t.child2.aabb),t;const s=t.child1,e=t.child2,i=this.getHeight(e)-this.getHeight(s);if(i>1){const s=e.child1,i=e.child2;return e.child1=t,e.parent=t.parent,t.parent=e,null!=e.parent?e.parent.child1===t?e.parent.child1=e:e.parent.child2=e:this.root=e,this.getHeight(s)>this.getHeight(i)?(e.child2=s,t.child2=i,i.parent=t):(t.child2=s,s.parent=t),t.aabb=v(t.child1.aabb,t.child2.aabb),e.aabb=v(e.child1.aabb,e.child2.aabb),e}if(i<-1){const e=s.child1,i=s.child2;return s.child1=t,s.parent=t.parent,t.parent=s,null!=s.parent?s.parent.child1===t?s.parent.child1=s:s.parent.child2=s:this.root=s,this.getHeight(e)>this.getHeight(i)?(s.child2=e,t.child1=i,i.parent=t):(s.child2=i,t.child1=e,e.parent=t),t.aabb=v(t.child1.aabb,t.child2.aabb),s.aabb=v(s.child1.aabb,s.child2.aabb),s}return t.aabb=v(t.child1.aabb,t.child2.aabb),t}toArray(t){const s=(t,e)=>t?t.isLeaf?t.objectLink.name:[s(t.child1),s(t.child2)]:null;return t||(t=this.root),s(t)}getHeight(t){const s=(t,e)=>{if(!t)return e;let i=s(t.child1,e+1),r=s(t.child2,e+1);return i>r?i:r};return s(t,1)}getNodes(){const t=(s,e)=>{e.push(s),s.child1&&t(s.child1,e),s.child2&&t(s.child2,e)},s=[];return t(this.root,s),s}}const{sum:R,diff:_,scale:M,cross:E,dot:P,normalize:I,norm:T,normSq:V}=t.vector,L=(t,s,e)=>(s[0]-t[0])*(e[1]-t[1])-(s[1]-t[1])*(e[0]-t[0])<=.001,S=(t,s,e)=>s[0]*e[1]+e[0]*t[1]+t[0]*s[1]-t[0]*t[1]-e[0]*s[1]-t[0]*e[1]<0?1:-1,B=(t,s,e,i)=>{if(s[0]-t[0]==0){const s=t[0],r=(i[1]-e[1])/(i[0]-e[0]);return[s,r*s+(e[1]-r*e[0])]}if(i[0]-e[0]==0){const i=e[0],r=(s[1]-t[1])/(s[0]-t[0]);return[i,r*i+(t[1]-r*t[0])]}const r=(s[1]-t[1])/(s[0]-t[0]),o=t[1]-r*t[0],n=(i[1]-e[1])/(i[0]-e[0]),a=(e[1]-n*e[0]-o)/(r-n);return[a,r*a+o]},{dot:N,cross:J,normalize:C,diff:F,scale:D,norm:U,sum:O}=t.vector;class j{constructor({body1:t,body2:s,n:e,ra:i,rb:r}){this.bias=null,this.n=e,this.J=null,this.invMass1=null,this.JM=null,this.body1=t,this.body2=s,this.ra=i,this.rb=r}updateEq(){const{body1:s,body2:e,n:i,ra:r,rb:o}=this;this.J=[D(i,-1),J(i,r),i,J(o,i)];const n=s.inverseInertia,a=e.inverseInertia,h=s.inverseMass,c=e.inverseMass;this.JM=[D(this.J[0],h),t.m3.transformPoint(n,this.J[1]),D(this.J[2],c),t.m3.transformPoint(a,this.J[3])],this.effMass=h+N(this.JM[0],this.J[1])+c+N(this.JM[3],this.J[3]),this.relativeVelocity=F(O(e.velocity,J(e.angularV,o)),O(s.velocity,J(s.angularV,r))),this.relativeVelocityNormalProjection=N(this.relativeVelocity,i)}applyResolvingImpulse(t){}}const k=(t,s,e)=>t>s?t<e?t:e:s;class z extends j{constructor({raLocal:t,rbLocal:s,ra:e,rb:i,n:r,penDepth:o,body1:n,body2:a,i:h,j:c}){super({ra:e,rb:i,n:r,body1:n,body2:a}),this.penDepth=o,this.initialVelProj=null,this.effMass=null,this.raLocal=t,this.rbLocal=s,this.J=null,this.accI=0,this.accFI1=0,this.accFI2=0,this.i=h,this.j=c,this.relativeVelocity=null}_J(){return[D(this.n,-1),J(this.n,this.ra),this.n,J(this.rb,this.n)]}applyResolvingImpulse(t){t<0||(this.effMass,t=Math.min(10,t),this.body1.applyImpulse(D(this.J[0],t),this.ra),this.body2.applyImpulse(D(this.J[2],t),this.rb),this.applyFrictionImpulse(t))}applyFrictionImpulse(t){const{ra:s,rb:e,body1:i,body2:r,i:o,j:n}=this,a=new j({body1:i,body2:r,n:D(o,-1),ra:s,rb:e}),h=new j({body1:i,body2:r,n:D(n,-1),ra:s,rb:e});a.updateEq(),h.updateEq();let c=i.friction+i.friction,l=(a.relativeVelocityNormalProjection-.01)/a.effMass;l=k(l,-t*c,t*c);let u=(h.relativeVelocityNormalProjection-.01)/h.effMass;u=k(u,-t*c,t*c),this.accFI1+=l,this.accFI2+=u;let d=O(D(o,l),D(n,u));i.applyImpulse(D(d,-1),s),r.applyImpulse(d,e)}applyResolvingPseudoImpulse(t){t<0||(this.effMass,t=Math.max(Math.min(100,t)-.1,0),this.body1.applyPseudoImpulse(D(this.J[0],t),this.ra),this.body2.applyPseudoImpulse(D(this.J[2],t),this.rb))}}const{dot:X,cross:Y,normalize:q,sum:G,diff:H,len:W,scale:K,isNull:$,norm:Q}=t.vector,Z=(s,e)=>{const i=s.getNormalsGlobal();let r=X(e,i[0]),o=0;for(let t=1,s=i.length;t<s;t++){const s=X(i[t],e);s<r&&(r=s,o=t)}const n=s.indices[o],a=s.getM4();return[n.map((e=>t.m4.transformPoint(a,s.points[e]))),i[o]]},tt=(t,s,e)=>{const[i,r]=t,o=X(r,e),n=H(s,i),a=X(n,r)/o;return H(s,K(e,a))},st=(t,s,e=1)=>{const[i,r]=t;return X(r,H(s,i))*e>-.05},et=(t,s)=>{const[e,i]=t,r=H(s,e),o=X(i,r);return H(s,K(i,o))},it=(t,s,e)=>[X(t,e),X(s,e)];function rt(t,s,e,i,r,o){const n=Y(H(this.b,this.a),H(this.c,this.a)),a=K(this.a,-1);return this.simp_dim=2,X(Y(H(this.b,this.a),n),a)>0?(this.c=this.a,void(this.search_dir=Y(Y(H(this.b,this.a),a),H(this.b,this.a)))):X(Y(n,H(this.c,this.a)),a)>0?(this.b=this.a,void(this.search_dir=Y(Y(H(this.c,this.a),a),H(this.c,this.a)))):(this.simp_dim=3,X(n,a)>0?(this.d=this.c,this.c=this.b,this.b=this.a,void(this.search_dir=n)):(this.d=this.b,this.b=this.a,void(this.search_dir=K(n,-1))))}function ot(t,s,e,i,r,o){const n=Y(H(this.b,this.a),H(this.c,this.a)),a=Y(H(this.c,this.a),H(this.d,this.a)),h=Y(H(this.d,this.a),H(this.b,this.a)),c=K(this.a,-1);return this.simp_dim=3,X(n,c)>0?(this.d=this.c,this.c=this.b,this.b=this.a,this.search_dir=n,!1):X(a,c)>0?(this.b=this.a,this.search_dir=a,!1):!(X(h,c)>0&&(this.c=this.d,this.d=this.b,this.b=this.a,this.search_dir=h,1))}const nt=(t,s)=>{let e=t[0][0],i=t[1][0],r=t[2][0],o=s[0],n=t[0][1],a=t[1][1],h=t[2][1],c=s[1],l=t[0][2],u=t[1][2],d=t[2][2],m=s[2];const f=e*a*d+n*u*r+i*h*l-r*a*l-n*i*d-u*h*e;return[(o*a*d+c*u*r+i*h*m-r*a*m-c*i*d-u*h*o)/f,(e*c*d+n*m*r+o*h*l-r*c*l-e*m*h-n*o*d)/f,(e*a*m+n*u*o+i*c*l-o*a*l-n*i*m-c*u*e)/f]},at=t=>{const s=t[3],e=t[0],i=-(-s[0]*e[0]-s[1]*e[1]-s[2]*e[2])/(s[0]*s[0]+s[1]*s[1]+s[2]*s[2]);return[i*s[0],i*s[1],i*s[2]]},ht=(t,s,e,i,r,o,n)=>{const a=o.collider,h=n.collider,c=[];for(let t=0;t<4;t++)c[t]=[];c[0][0]=t,c[0][1]=s,c[0][2]=e,c[0][3]=q(Y(H(s,t),H(e,t))),c[1][0]=t,c[1][1]=e,c[1][2]=i,c[1][3]=q(Y(H(e,t),H(i,t))),c[2][0]=t,c[2][1]=i,c[2][2]=s,c[2][3]=q(Y(H(i,t),H(s,t))),c[3][0]=s,c[3][1]=i,c[3][2]=e,c[3][3]=q(Y(H(i,s),H(e,s)));let l,u,d=4,m=null;for(let t=0;t<64;++t){let t=X(c[0][0],c[0][3]);m=0;for(let s=0;s<d;++s){let e=X(c[s][0],c[s][3]);e<t&&(t=e,m=s)}l=c[m][3];const s=a.support(K(l,-1)),e=h.support(l);if(u=H(e,s),r.set(u,[s,e]),X(u,l)-t<1e-5){const t=c[m],s=at(t),[e,i]=r.get(t[0]),[o,n]=r.get(t[1]),[a,h]=r.get(t[2]),d=nt(t,s);if(isNaN(d[0]+d[1]+d[2]))return console.log("no conv"),null;let f=G(G(K(e,d[0]),K(o,d[1])),K(a,d[2])),p=G(G(K(i,d[0]),K(n,d[1])),K(h,d[2]));const b=q(K(t[3],-X(u,l)));return Q(b)<.01?null:{PA:f,PB:p,n:b,penDepth:-X(H(p,f),b)}}const i=[];let o=0;for(let t=0;t<d;++t)if(X(c[t][3],H(u,c[t][0]))>0){for(let s=0;s<3;s++){let e=[c[t][s],c[t][(s+1)%3]],r=!1;for(let t=0;t<o;t++)i[t][1]===e[0]&&i[t][0]===e[1]&&(i[t][0]=i[o-1][0],i[t][1]=i[o-1][1],o--,r=!0,t=o);if(!r){if(o>=32)break;i[o]=[],i[o][0]=e[0],i[o][1]=e[1],o++}}c[t][0]=c[d-1][0],c[t][1]=c[d-1][1],c[t][2]=c[d-1][2],c[t][3]=c[d-1][3],d--,t--}for(let t=0;t<o&&!(d>=64);t++){if(c[d]=[],c[d][0]=i[t][0],c[d][1]=i[t][1],c[d][2]=u,c[d][3]=q(Y(H(i[t][0],i[t][1]),H(i[t][0],u))),X(c[d][0],c[d][3])+.01<0){const t=c[d][0];c[d][0]=c[d][1],c[d][1]=t,c[d][3]=K(c[d][3],-1)}d++}}return console.log("no conv"),null},ct=function(t,s){const e=t.collider,i=s.collider;this.a=[0,0,0],this.b=[0,0,0],this.c=[0,0,0],this.d=[0,0,0],this.search_dir=[0,0,0],this.simp_dim=0,this.originsMap=new Map,this.search_dir=H(e.pos,i.pos);const r=e.support(K(this.search_dir,-1)),o=i.support(this.search_dir);this.c=H(o,r),this.originsMap.set(this.c,[r,o]),this.search_dir=K(this.c,-1);const n=e.support(K(this.search_dir,-1)),a=i.support(this.search_dir);if(this.b=H(a,n),this.originsMap.set(this.b,[n,a]),X(this.b,this.search_dir)<0)return null;this.search_dir=Y(Y(H(this.c,this.b),K(this.b,-1)),H(this.c,this.b)),$(this.search_dir)&&(this.search_dir=Y(H(this.c,this.b),[1,0,0]),$(this.search_dir)&&(this.search_dir=Y(H(this.c,this.b),[0,0,-1]))),this.simp_dim=2;for(let r=0;r<64;++r){const r=e.support(K(this.search_dir,-1)),o=i.support(this.search_dir);if(this.a=H(o,r),this.originsMap.set(this.a,[r,o]),X(this.a,this.search_dir)<0)return null;if(this.simp_dim++,3===this.simp_dim)rt.apply(this);else if(ot.apply(this))return ht(this.a,this.b,this.c,this.d,this.originsMap,t,s)}return null}.bind({}),lt=(s,e)=>{const i=s.collider,r=e.collider,o=ct(s,e);if(o){const{PA:n,PB:a,n:h}=o,c=K(h,-1),[l,u]=Z(i,c),[d,m]=Z(r,h),f=[K(G(n,a),.5),h],p=l.map((t=>et(f,t))),b=d.map((t=>et(f,t))),g=f[0],y=t.vector.normalize(t.vector.diff(f[0],p[1])),v=t.vector.cross(f[1],y);let x=p.map((t=>it(y,v,H(t,g)))),w=b.map((t=>it(y,v,H(t,g))));const A=S(x[0],x[1],x[2]),R=S(w[0],w[1],w[2]);A<0&&(x=x.map(((t,s)=>x.at(-s)))),R<0&&(w=w.map(((t,s)=>w.at(-s))));const _=((t,s,e=1,i=1)=>{let r=[...t];for(let t=0,o=s.length;t<o;t++){const o=[...r];r=[];const n=s.at((t-1)*e),a=s.at(t*e);for(let t=0,s=o.length;t<s;t++){const s=o.at((t-1)*i),e=o.at(t*i);if(L(n,a,e)){if(!L(n,a,s)){const t=B(s,e,n,a);r.push(t)}r.push(e)}else if(L(n,a,s)){const t=B(s,e,n,a);r.push(t)}}}return r})(x,w,A,R),M=_.map((t=>G(g,G(K(y,t[0]),K(v,t[1]))))),E=[];if(M.forEach((o=>{const n=tt([l[0],u],o,h);if(!st(f,n,1))return;const a=tt([d[0],m],o,h);if(!st(f,a,-1))return;const c=H(a,r.pos),p=H(n,i.pos),b=-X(H(a,n),h),g=t.m3.transformPoint(i.RmatrixInverse,p),x=t.m3.transformPoint(r.RmatrixInverse,c);E.push({raLocal:g,rbLocal:x,ra:p,rb:c,PA:n,PB:a,n:h,penDepth:b,body1:s,body2:e,i:y,j:v})})),0===E.length){const o=H(a,r.pos),c=H(n,i.pos),l=-X(H(a,n),h),u=t.m3.transformPoint(i.RmatrixInverse,c),d=t.m3.transformPoint(r.RmatrixInverse,o);E.push({raLocal:u,rbLocal:d,ra:c,rb:o,PA:n,PB:a,n:h,penDepth:l,body1:s,body2:e,i:y,j:v})}return E}return null},{distanceFromLine:ut,norm:dt,findFurthestPoint:mt,sum:ft,diff:pt,normSq:bt,dot:gt}=t.vector,yt=5e-4;class vt{constructor(...t){this.contacts=t,this.keep=!0}update(){const s=this.contacts;if(s.length<2)this.keep=!1;else for(let e=0,i=s.length;e<i;e++){const i=s[e],r=i.body1.collider.pos,o=i.body2.collider.pos,n=t.m3.transformPoint(i.body1.collider.Rmatrix,i.raLocal),a=t.m3.transformPoint(i.body2.collider.Rmatrix,i.rbLocal),h=ft(r,n),c=ft(o,a),l=pt(i.PA,h),u=pt(i.PB,c);if(dt(l)>yt||dt(u)>yt)return void(this.keep=!1);i.PA=h,i.PB=c,i.ra=n,i.rb=a,i.penDepth=gt(i.n,pt(c,h))}}}class xt{constructor(...t){this.constraints=[...t],this.JMJ=null,this.JV=null,this.JpV=null,this.JMJp=null}addConstraint(...t){this.constraints.push(...t)}generatePseudoVelVector(){}generateSystem(s){const e=this.constraints.length;this.JMJp=new Array(e*e),this.JMJ=new Array(e*e),this.JV=new Array(e),this.JpV=new Array(e);for(let s=0;s<e;s++){const i=this.constraints[s],{body1:r,body2:o,JM:n,J:a}=i,h=s*e;for(let s=0;s<e;s++){if(h===s){this.JMJ[h+s]=()=>i.effMass,this.JMJp[h+s]=()=>i.body1.inverseMass+i.body2.inverseMass;continue}const e=this.constraints[s],a=e.body1,c=e.body2,l=e.J,u=r===a?()=>t.vector.dot(n[0],l[0]):()=>0,d=o===c?()=>t.vector.dot(n[2],l[2]):()=>0,m=r===c?()=>t.vector.dot(n[0],l[2]):()=>0,f=o===a?()=>t.vector.dot(n[2],l[0]):()=>0,p=r===a?()=>t.vector.dot(n[0],l[0])+t.vector.dot(n[1],l[1]):()=>0,b=o===c?()=>t.vector.dot(n[2],l[2])+t.vector.dot(n[3],l[3]):()=>0,g=r===c?()=>t.vector.dot(n[0],l[2])+t.vector.dot(n[1],l[3]):()=>0,y=o===a?()=>t.vector.dot(n[2],l[0])+t.vector.dot(n[3],l[1]):()=>0;this.JMJ[h+s]=()=>p()+b()+g()+y(),this.JMJp[h+s]=()=>u()+d()+m()+f()}this.JV[s]=()=>-i.relativeVelocityNormalProjection,this.JpV[s]=t=>-i.relativeVelocityNormalProjection+Math.max(0,i.penDepth-.1)/t*.125}}getJMJ(){return this.JMJ.map((t=>t()))}getJv(){return this.JV.map((t=>t()))}getJpV(t){return this.JpV.map((s=>s(t)))}getJMJp(){return this.JMJp.map((t=>t()))}getUpdatedValues(t){return[this.JMJ.map((t=>t())),this.JV.map((t=>t())),this.JpV.map((s=>s(t)))]}applyResolvingImpulses(t){for(let s=0,e=this.constraints.length;s<e;s++)this.constraints[s].applyResolvingImpulse(t[s])}applyResolvingPseudoImpulses(t){for(let s=0,e=this.constraints.length;s<e;s++)this.constraints[s].applyResolvingPseudoImpulse(t[s])}}let wt=(t,s)=>t.map(((t,e)=>t-s[e])).reduce(((t,s)=>t+s**2),0);const At=(t,s,e,i)=>{let r=new Array(e).fill(0),o=!1,n=64,a=[];for(;!o&&n>0;){n--,a=[...r];for(let i=0;i<e;i++){let o=0;for(let s=0;s<i;s++)o+=t[i*e+s]*a[s];for(let s=i+1;s<e;s++)o+=t[i*e+s]*r[s];a[i]=(s[i]-o)/t[i*e+i]}o=wt(r,a)<i,r=[...a]}return a},{cross:Rt,scale:_t,norm:Mt,sum:Et,diff:Pt,chkV:It}=t.vector,Tt=1e-4,Vt=.011;class Lt extends y{constructor(t){super(),this.static=!1,this.collider=t,this.mass=1,this.inverseMass=1/this.mass,this.velocity=[0,0,0],this.pseudoVelocity=[0,0,0],this.pseudoAngularV=[0,0,0],this.acceleration=[0,0,0],this.angularV=[0,0,0],this.inverseInertia=t.getInverseInertiaTensor(this.mass),this.id=1,this.friction=.5,this.BVlink}integrate(t){const{acceleration:s,velocity:e,translation:i}=this;this.translate(_t(this.velocity,t));const r=_t(this.angularV,t);Mt(r)>Vt&&this.rotate(r);let o=_t(this.acceleration,t);this.velocity=Et(this.velocity,o)}integratePseudoVelocities(t){const s=_t(this.pseudoVelocity,t),e=_t(this.pseudoAngularV,t);Mt(s)>Vt&&this.translate(s),Mt(e)>Vt&&this.rotate(e),this.pseudoVelocity=[0,0,0],this.pseudoAngularV=[0,0,0]}addPseudoVelocity(t){this.pseudoVelocity=Et(this.pseudoVelocity,t)}addPseudoAngularV(t){this.pseudoAngularV=Et(this.pseudoAngularV,t)}integrateVelocities(t){const s=_t(this.velocity,t);Mt(s)>Vt&&this.translate(s);const e=_t(this.angularV,t);Mt(s)>Vt&&this.rotate(e)}integrateForces(t){let s=_t(this.acceleration,t);this.velocity=Et(this.velocity,s)}updateInverseInertia(){this.inverseInertia=this.collider.getInverseInertiaTensor(this.mass)}getItensor(){return this.collider.getInverseInertiaTensor(this.mass)}setMass(t){this.mass=t,this.inverseMass=1/this.mass}translate(t){this.collider.translate(t),this.emit("update")}rotate(t){this.collider.rotate(t),this.emit("update")}applyImpulse(s,e){this.velocity=Et(this.velocity,_t(s,this.inverseMass));const i=t.m3.transformPoint(this.inverseInertia,Rt(e,s));this.angularV=Et(this.angularV,i)}applyPseudoImpulse(s,e){this.pseudoVelocity=Et(this.pseudoVelocity,_t(s,this.inverseMass));const i=t.m3.transformPoint(this.inverseInertia,Rt(e,s));this.pseudoAngularV=Et(this.pseudoAngularV,i)}addVelocity(t){It(t),this.static||(this.velocity=Et(this.velocity,t))}addAngularV(t){It(t),this.static||(this.angularV=Et(this.angularV,t))}addAcceleration(t){this.acceleration=Et(this.acceleration,t)}getExpandedAABB(){const t=this.collider.getAABB(),s=(this.velocity,[Tt,Tt,Tt]);return t.min=Pt(t.min,s),t.max=Et(t.max,s),t}getAABB(){return this.collider.getAABB()}}const{scale:St,sum:Bt,diff:Nt}=t.vector,Jt=[1,0,0],Ct=[0,1,0],Ft=[0,0,1],Dt=St(Jt,-1),Ut=St(Ct,-1),Ot=St(Ft,-1);class jt{constructor(s=1,e=1,i=1){this.min=[-s/2,-e/2,-i/2],this.max=[s/2,e/2,i/2],this.Rmatrix=t.m3.identity(),this.RmatrixInverse=t.m3.identity(),this.RS=t.m3.identity(),this.TRS=t.m4.identity(),this.pos=[0,0,0],this.points=[[-.5,-.5,-.5],[.5,-.5,-.5],[.5,-.5,.5],[-.5,-.5,.5],[-.5,.5,-.5],[.5,.5,-.5],[.5,.5,.5],[-.5,.5,.5]],this.indices=[[0,4,5,1],[3,7,6,2],[0,1,2,3],[4,5,6,7],[0,3,7,4],[1,2,6,5]],this.normals=[[0,0,-1],[0,0,1],[0,-1,0],[0,1,0],[-1,0,0],[1,0,0]]}setScale(t){const[s,e,i]=t;this.min=[-s/2,-e/2,-i/2],this.max=[s/2,e/2,i/2]}setTranslation(t){this.pos=[...t],console.log(this.pos)}getNormalsGlobal(){return this.normals.map((s=>t.m3.transformPoint(this.Rmatrix,s)))}getAABB(){const s=this.support(Jt)[0],e=this.support(Ct)[1],i=this.support(Ft)[2],r=this.support(Dt)[0],o=this.support(Ut)[1],n=this.support(Ot)[2];return new t.AABB([r,o,n],[s,e,i])}translate(t){this.pos=Bt(this.pos,t)}rotate(s){this.Rmatrix=t.m3.xRotate(this.Rmatrix,s[0]),this.Rmatrix=t.m3.yRotate(this.Rmatrix,s[1]),this.Rmatrix=t.m3.zRotate(this.Rmatrix,s[2]),this.RmatrixInverse=t.m3.transpose(this.Rmatrix)}setRmatrix(s){console.log(this.Rmatrix),this.Rmatrix=[...s],console.log(this.Rmatrix),this.RmatrixInverse=t.m3.transpose(s)}setTRMatrix(s){t.m4.m4Tom3(s),this.setRmatrix(s);const e=[s[12],s[13],s[14]];this.translate(e)}setTRS(s){const{translation:e,Rmatrix:i,scale:r}=t.m4.decompose(s);this.setTranslation(e),this.setRmatrix(t.m4.m4Tom3(i)),this.setScale(r),console.log(e,i,r)}support(s){const e=t.m3.transformPoint(this.RmatrixInverse,s),i=[0,0,0];i[0]=e[0]>0?this.max[0]:this.min[0],i[1]=e[1]>0?this.max[1]:this.min[1],i[2]=e[2]>0?this.max[2]:this.min[2];const r=t.m3.transformPoint(this.Rmatrix,i);return Bt(r,this.pos)}getInverseInertiaTensor(s){const e=s/12*(this.max[1]*this.max[1]+this.max[2]*this.max[2]),i=s/12*(this.max[0]*this.max[0]+this.max[2]*this.max[2]),r=s/12*(this.max[0]*this.max[0]+this.max[1]*this.max[1]),o=new Float32Array([1/e,0,0,0,1/i,0,0,0,1/r]);return t.m3.multiply(t.m3.multiply(this.Rmatrix,o),this.RmatrixInverse)}getM4(){const s=t.m4.m3Tom4(this.Rmatrix);s[12]=this.pos[0],s[13]=this.pos[1],s[14]=this.pos[2],s[15]=1;const e=Nt(this.max,this.min);return t.m4.scale(s,...e)}localToGlobal(s){let e=t.m3.transformPoint(this.Rmatrix,s);return Bt(this.pos,e)}}const kt={w:"moveForward",s:"moveBackward",a:"moveLeft",d:"moveRight"},zt=new class extends y{constructor(){super(),this.lastX=0,this.lastY=0,this.enable=!1}logMove({offsetX:t,offsetY:s}){const e=t-this.lastX;this.lastX=t;const i=s-this.lastY;this.lastY=s,this.emit("move",[e,i])}listen(){const t=this.logMove.bind(this),s=function(s){this.enable&&t(s)}.bind(this),e=function({offsetX:t,offsetY:s}){this.lastX=t,this.lastY=s,this.enable=!0}.bind(this),i=function(){this.enable=!1}.bind(this);document.addEventListener("mousemove",s),document.addEventListener("mousedown",e),document.addEventListener("mouseup",i),this.unsubscribe=()=>{document.removeEventListener("mousemove",s),document.removeEventListener("mousedown",e),document.removeEventListener("mouseup",i)}}};zt.listen();const Xt=new class{constructor(){this.keys=new Set}logDown({key:t}){this.keys.add(t)}logUp({key:t}){this.keys.delete(t)}listen(){const t=this.logDown.bind(this),s=this.logUp.bind(this);document.addEventListener("keydown",t),document.addEventListener("keyup",s),this.unsubsicribe=()=>{document.removeEventListener("keydown",t),document.removeEventListener("keyup",s)}}};Xt.listen();const Yt=new class{constructor(t){const s=document.querySelector(`#${t}`).getContext("webgl2");if(!s)throw new Error("No webgl!");this.gl=s,this.textures={},this.renderCache={lastUsedProgramInfo:null},this.programs={}}getLastUsedProgramInfo(){return this.renderCache.lastUsedProgramInfo}setLastUsedProgram(t){return this.renderCache.lastUsedProgramInfo=t,this}useProgramInfo(t){return t!=this.getLastUsedProgramInfo()&&(this.gl.useProgram(t.program),this.setLastUsedProgram(t)),this}resizeCanvasToDisplaySize(t=1){const s=this.gl.canvas,e=s.clientWidth*t|0,i=s.clientHeight*t|0;return s.width=e,s.height=i,this}resizeCanvas(t,s){const e=this.gl.canvas;return e.width=t,e.height=s,this}getContext(){return this.gl}getCanvasRect(){return this.gl.canvas.getBoundin}createTexture(t){const s=new p(this.gl);return this.textures={...this.textures,[t]:s},this}getTexture(t){return this.textures[t]}setTextureUnit(t,s){const e=this.getTexture(t).texture;return((t,s,e)=>{t.activeTexture(t.TEXTURE0+e),t.bindTexture(t.TEXTURE_2D,s)})(this.gl,e,s),this}}("canvas"),qt=Yt.getContext();Yt.resizeCanvasToDisplaySize();const Gt=new class{constructor(){this.context=null,this.projectionMatrix=null,this.fieldOfViewRadians=d(90)}setContext(t){return this.context=t,this}setFieldOfView(t){return this.fieldOfViewRadians=d(t),this}update3DProjectionMatrix(s=.01,e=2e3){const{gl:i}=this.context,r=i.canvas.clientWidth/i.canvas.clientHeight;return this.projectionMatrix=t.m4.perspective(m,r,s,e),this}getViewProjectionMatrix(s){const{projectionMatrix:e}=this,{gl:i}=this.context,r=t.m4.inverse(s);return t.m4.multiply(e,r)}draw(s,e,i){const r=this.getViewProjectionMatrix(i),{vao:o,mode:n,offset:a,numElements:h,indices:c,componentType:l,programInfo:u}=s,{gl:d}=this.context,m=t.m4.multiply(r,e.u_matrix),f=e.u_matrix;this.context.useProgramInfo(u),this.context.getLastUsedProgramInfo().setUniforms({...e,worldMatrix:f,worldViewProjection:m}),o&&d.bindVertexArray(o),c?d.drawElements(n,h,l,a):d.drawArrays(n,a,h)}drawInstanced(s,e,i,r){const o=this.getViewProjectionMatrix(i),{gl:n}=this.context,{vao:a,mode:h,offset:c,numElements:l,indices:u,programInfo:d}=s,m=t.m4.multiply(o,e.u_matrix),f=e.u_matrix;this.context.useProgramInfo(d),this.context.getLastUsedProgramInfo().setUniforms({...e,worldMatrix:f,worldViewProjection:m}),n.bindVertexArray(a),u?n.drawElementsInstanced(h,l,n.UNSIGNED_SHORT,c,r):n.drawArraysInstanced(h,c,l,r)}};Gt.setContext(Yt).update3DProjectionMatrix(),g.setContext(Yt).compileShaders().createUniformSetters();const Ht=new h(function(t=1,s=1,e=1){const i=t/2,r=s/2,o=e/2,n=[[-i,-r,-o],[+i,-r,-o],[-i,+r,-o],[+i,+r,-o],[-i,-r,+o],[+i,-r,+o],[-i,+r,+o],[+i,+r,+o]],a=[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]],h=c(new Float32Array(72)),l=c(new Float32Array(72)),d=c(new Uint16Array(36));for(let t=0;t<6;++t){const s=u[t];for(let e=0;e<4;++e){const i=n[s[e]],r=a[t];h.push(i),l.push(r)}const e=4*t;d.push(e+0,e+1,e+2),d.push(e+0,e+2,e+3)}h.byteLength;const m=new Float32Array([0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1]);return{attributes:{NORMAL:{data:l,count:72,location:1,byteLength:l.byteLength,stride:0,offset:0,numComponents:3,type:5126},POSITION:{data:h,count:72,location:0,byteLength:h.byteLength,stride:0,offset:0,numComponents:3,type:5126},TEXCOORD_0:{data:m,count:48,type:5126,offset:0,stride:0,byteLength:m.byteLength,location:4,numComponents:2}},indices:d,numElements:d.length,componentType:5123,mode:4}}(1,1,1)),Wt=new h(((t,s)=>{const e=[0,0,0],i=[],r=[];for(let t=0;t<5;t++){const s=2*t*Math.PI/4,r=8*Math.cos(s),o=8*Math.sin(s);e.push(r,0,o),i.push(0,1,0)}for(let t=0;t<4;t++)r.push(0,t+1,t+2);const o=new Float32Array(i),n=new Float32Array(e),a=new Uint16Array(r);return{attributes:{POSITION:{location:0,count:e.length,offset:0,stride:0,numComponents:3,type:5126,data:n,byteLength:n.byteLength},NORMAL:{location:1,count:i.length,numComponents:3,offset:0,stride:0,type:5126,data:o,byteLength:o.byteLength}},componentType:5123,indices:a,numElements:r.length,mode:4}})()),Kt=new h({mode:qt.POINTS,numElements:2,offset:0}),$t=new h({mode:qt.LINES,numElements:2,offset:0});Ht.setContext(Yt).createVAO().setDrawer(Gt).setProgramInfo(g).createGeometryBuffers().setAttributes().setMode(2),Wt.setContext(Yt).createVAO().setDrawer(Gt).setProgramInfo(g).createGeometryBuffers().setAttributes().setMode(3),$t.setContext(Yt).createVAO().setDrawer(Gt).setProgramInfo(g).createBufferAttribData("a_position","vec3",{location:0}).setOwnAttribute("a_position").bufferData("a_position",new Float32Array([0,0,0,0,1,0])),Kt.setContext(Yt).createVAO().setDrawer(Gt).setProgramInfo(g).createBufferAttribData("a_position","vec3",{location:0}).setOwnAttribute("a_position").bufferData("a_position",new Float32Array([0,0,0]));const Qt=new class{constructor(){this.objects=[],this.bvh=new A,this.collisions=[],this.constraints=new Map,this.collisionManifolds=new Map,this.lastId=0}addObject(t){const s=t.getExpandedAABB(),e=this.bvh.insertLeaf(s,t);t.BVlink=e,t.id=this.lastId,this.lastId++,t.on("update",(()=>this.updateObjectAABB.call(this,t))),this.objects.push(t)}addConstraints(t,s){const e=new xt(...t);e.generateSystem();const i=new xt(...t);i.generateSystem(),this.constraints.set(s,[e,i])}updateObjectAABB(t){const s=t.getAABB();this.bvh.removeLeaf(t.BVlink);const e=this.bvh.insertLeaf(s,t);t.BVlink=e}removeObject(t){this.bvh.removeLeaf(t.BVlink),this.objects=this.objects.filter((s=>s===t))}updateCollisions(){const{collisionManifolds:t}=this;for(const[s,e]of t)e.update(),e.keep||t.delete(s);for(let t=0,i=this.objects.length;t<i;t++){const i=this.objects[t];if(i.static)continue;const r=this.bvh.getCollisions(i.BVlink);if(i.BVlink.isChecked=!0,0!=r.length)for(let t=0,o=r.length;t<o;t++){const o=(s=i.id,e=r[t].id,s===Math.max(s,e)?s*s+s+e:e*e+s+e);let n=this.collisionManifolds.get(o);if(n)continue;const a=lt(i,r[t]);a&&(n=new vt(...a),this.collisionManifolds.set(o,n))}}var s,e;this.bvh.setUnchecked()}tick(t){this.updateCollisions();let s=this.collisionManifolds.values();for(let s=0,e=this.objects.length;s<e;s++)this.objects[s].integrateForces(t);const e=new xt;for(let t of s){const s=t.contacts.map((t=>new z(t)));for(let t=0,e=s.length;t<e;t++)s[t].updateEq();e.addConstraint(...s)}e.generateSystem(t);const[i,r,o]=e.getUpdatedValues(t),n=At(i,r,e.constraints.length,1e-6);e.applyResolvingImpulses(n);for(const[s,e]of this.constraints){const s=e[0];s.constraints.forEach((t=>t.updateEq()));const[i,r]=s.getUpdatedValues(t),o=At(i,r,s.constraints.length,1e-6);s.applyResolvingImpulses(o)}for(let s=0,e=this.objects.length;s<e;s++)this.objects[s].integrateVelocities(t);s=this.collisionManifolds.values();const a=new xt;for(const t of s){const s=t.contacts.map((t=>new z(t)));s.forEach((t=>t.updateEq())),s.length>2&&a.addConstraint(...s)}a.generateSystem(t);const h=a.getJMJ(),c=a.getJpV(t),l=At(h,c,a.constraints.length,1e-6);a.applyResolvingPseudoImpulses(l,t);for(const[s,e]of this.constraints){const s=e[1];s.constraints.forEach((t=>t.updateEq()));const i=s.getJMJ(),r=s.getJpV(t),o=At(i,r,s.constraints.length,1e-6);s.applyResolvingPseudoImpulses(o)}for(let s=0,e=this.objects.length;s<e;s++)this.objects[s].integratePseudoVelocities(t);this.objects.forEach((t=>t.updateInverseInertia()))}},Zt={physics:new Lt(new jt(1e3,6,1e3)),sprite:Ht},ts={physics:new Lt(new jt(5,5,5)),sprite:Ht},ss={physics:new Lt(new jt(5,5,5)),sprite:Ht},es={physics:new class extends Lt{constructor(){super(...arguments),this.friction=0}applyImpulse(t,s){this.velocity=Et(this.velocity,_t(t,this.inverseMass))}applyPseudoImpulse(t){this.pseudoVelocity=Et(this.pseudoVelocity,_t(t,this.inverseMass))}}(new jt(5,5,5)),sprite:Ht};ts.physics.translate([0,10,-10]),ts.physics.addAcceleration([0,3,0]),ss.physics.addAcceleration([0,-9.8,0]),es.physics.addAcceleration([0,-9.8,0]),Qt.addObject(Zt.physics),Qt.addObject(ts.physics),Qt.addObject(ss.physics),Qt.addObject(es.physics);const is=[Zt,ts,ss,es];Qt.addConstraints([new class extends j{constructor({localRa:t,localRb:s,body1:e,body2:i}){super({body1:e,body2:i}),this.localRa=t,this.localRb=s,this.PA=this.body1.collider.localToGlobal(this.localRa),this.PB=this.body2.collider.localToGlobal(this.localRb)}updateEq(){this.PA=this.body1.collider.localToGlobal(this.localRa),this.PB=this.body2.collider.localToGlobal(this.localRb),this.n=F(this.PA,this.PB),this.ra=F(this.PA,this.body1.collider.pos),this.rb=F(this.PB,this.body2.collider.pos),this.penDepth=U(this.n),this.J=[D(this.n,-1),J(this.n,this.ra),D(this.n,1),J(this.rb,this.n)];const s=this.body1.inverseInertia,e=this.body2.inverseInertia,i=this.body1.inverseMass,r=this.body2.inverseMass;this.effMass=i+N(t.m3.transformPoint(s,this.J[1]),this.J[1])+r+N(t.m3.transformPoint(e,this.J[3]),this.J[3]),this.relativeVelocity=F(O(this.body2.velocity,J(this.body2.angularV,this.rb)),O(this.body1.velocity,J(this.body1.angularV,this.ra))),this.relativeVelocityNormalProjection=N(this.relativeVelocity,this.n)}applyResolvingImpulse(t){t<0||(this.effMass,t=Math.min(10,t),this.body1.applyImpulse(D(this.J[0],t),this.ra),this.body2.applyImpulse(D(this.J[2],t),this.rb))}applyResolvingPseudoImpulse(t){t<0||(this.effMass,t=Math.max(Math.min(100,t)-.1,0),this.body1.applyPseudoImpulse(D(this.J[0],t),this.ra),this.body2.applyPseudoImpulse(D(this.J[2],t),this.rb))}}({localRa:[0,-3,0],localRb:[0,3,0],body1:ts.physics,body2:ss.physics})],"name");for(let t=0;t<0;t++){const s={physics:new Lt(new jt(5,5,5)),sprite:Ht};s.physics.translate([0,5*t+2,0]),s.physics.setMass(10),s.physics.addAcceleration([0,-9.8,0]),Qt.addObject(s.physics),is.push(s)}Zt.physics.setMass(1e8),ts.physics.setMass(2),Zt.physics.translate([0,-3,0]),Zt.static=!0;const rs=new class{constructor(s){this.rigidBody=s,this.keyInput=null,this.mouseInput=null,this.rotationX=0,this.rotationY=0,this.deltaRY=0,this.camPos=[0,0,10],this.camRot=t.m3.identity()}listenMouse(t){this.mouseInput=t,t.on("move",(([t,s])=>{this.rotationY-=.005*t,this.rotationX-=.005*s,this.rotationX=Math.max(-Math.PI/2,Math.min(Math.PI/2,this.rotationX)),this.deltaRY=.005*t}))}listenKeyboard(t){this.keyInput=t}tick(){for(const t of this.keyInput.keys){const s=kt[t];s&&this[s].bind(this)()}t.m3.yRotation(this.rotationY),this.rigidBody.rotate([0,-this.deltaRY,0]),this.deltaRY=0;const s=[...this.rigidBody.collider.pos];let e=t.m4.translation(s[0],s[1]+3,s[2]);e=t.m4.multiply(e,t.m4.m3Tom4(this.rigidBody.collider.Rmatrix)),e=t.m4.xRotate(e,this.rotationX),e=t.m4.translate(e,...this.camPos),this.camMatrix=e}move(s){const e=this.rigidBody.collider.Rmatrix;this.rigidBody.applyImpulse(t.m3.transformPoint(e,s),[0,0,0])}moveForward(){this.move([0,0,-1])}moveBackward(){this.move([0,0,1])}moveLeft(){this.move([-1,0,0])}moveRight(){this.move([1,0,0])}}(es.physics);rs.listenKeyboard(Xt),rs.listenMouse(zt);let os=Date.now();const ns=document.querySelector("#fps");document.addEventListener("keypress",(t=>{"p"===t.key&&zt.unsubscribe()}));let as=0;const hs=()=>{Qt.tick(.015),rs.tick();const s=Date.now(),e=s-os;ns.textContent=1/e*1e3,os=s,qt.clear(qt.COLOR_BUFFER_BIT|qt.DEPTH_BUFFER_BIT),qt.enable(qt.CULL_FACE),qt.enable(qt.DEPTH_TEST);const i=rs.camMatrix;as+=.001;const r=Qt.collisionManifolds.values();for(const s of r)s.contacts.forEach((s=>{Kt.draw({u_matrix:t.m4.translation(...s.PA),u_color:[.6,.6,0,1]},i).draw({u_matrix:t.m4.translation(...s.PB),u_color:[.5,.1,.2,1]},i)}));is.forEach((s=>{t.vector.diff(s.physics.collider.max,s.physics.collider.min);const e=s.physics.collider.getM4();s.sprite.draw({u_color:[1,0,1,1],u_matrix:e},i)})),Wt.draw({u_matrix:t.m4.rotation(Math.PI/2,0,0),u_color:[1,.5,.1,1],u_worldViewPosition:i},i).draw({u_matrix:t.m4.identity(),u_color:[1,.5,.1,1],u_worldViewPosition:i},i),Kt.draw({u_matrix:t.m4.identity(),u_color:[0,.5,.1,1],u_worldViewPosition:i},i),qt.viewport(0,0,qt.canvas.width,qt.canvas.height),requestAnimationFrame(hs)};hs()})()})();